
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>writer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Soreing/parsley/writer/bool.go (100.0%)</option>
				
				<option value="file1">github.com/Soreing/parsley/writer/digits.go (100.0%)</option>
				
				<option value="file2">github.com/Soreing/parsley/writer/float.go (47.1%)</option>
				
				<option value="file3">github.com/Soreing/parsley/writer/int.go (0.0%)</option>
				
				<option value="file4">github.com/Soreing/parsley/writer/string.go (3.4%)</option>
				
				<option value="file5">github.com/Soreing/parsley/writer/time.go (0.0%)</option>
				
				<option value="file6">github.com/Soreing/parsley/writer/uint.go (0.0%)</option>
				
				<option value="file7">github.com/Soreing/parsley/writer/writer.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package writer

// BoolLen returns the byte length of an encoded boolean
func BoolLen(b bool) (bytes int) <span class="cov3" title="2">{
        if b </span><span class="cov1" title="1">{
                return 4
        }</span> else<span class="cov1" title="1"> {
                return 5
        }</span>
}

// BoolpLen returns the byte length of an encoded boolean pointer
func BoolpLen(b *bool) (bytes int) <span class="cov4" title="3">{
        if b == nil </span><span class="cov1" title="1">{
                return 4
        }</span> else<span class="cov3" title="2"> if *b </span><span class="cov1" title="1">{
                return 4
        }</span> else<span class="cov1" title="1"> {
                return 5
        }</span>
}

// BoolsLen returns the byte length of an encoded boolean slice
func BoolsLen(bs []bool) (bytes int) <span class="cov5" title="4">{
        if bs == nil </span><span class="cov1" title="1">{
                return 4
        }</span> else<span class="cov4" title="3"> if len(bs) == 0 </span><span class="cov1" title="1">{
                return 2
        }</span> else<span class="cov3" title="2"> {
                bytes = 6*len(bs) + 1
                for _, b := range bs </span><span class="cov5" title="5">{
                        if b </span><span class="cov4" title="3">{
                                bytes--
                        }</span>
                }
                <span class="cov3" title="2">return</span>
        }
}

// Bool writes an encoded boolean to the buffer
func (w *Writer) Bool(b bool) <span class="cov5" title="5">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        v, vln, cap := "false", 5, ln-cr

        if b </span><span class="cov4" title="3">{
                v, vln = "true", 4
        }</span>

        <span class="cov5" title="5">if vln &lt;= cap </span><span class="cov3" title="2">{
                w.Cursor += copy(bf[cr:], v)
        }</span> else<span class="cov4" title="3"> {
                copy(bf[cr:], v[:cap])
                w.Storage = append(w.Storage, bf)
                bf = make([]byte, vln-cap+CHUNK_SIZE)
                w.Cursor = copy(bf, v[cap:])
                w.Buffer = bf
        }</span>
}

// Boolp writes an encoded boolean pointer to the buffer. If the pointer is nil,
// it writes null
func (w *Writer) Boolp(b *bool) <span class="cov3" title="2">{
        if b == nil </span><span class="cov1" title="1">{
                w.Raw("null")
        }</span> else<span class="cov1" title="1"> {
                w.Bool(*b)
        }</span>
}

// Bools writes an encoded boolean slice to the buffer. The data includes
// commas and brackets. If the pointer is nil, it writes null
func (w *Writer) Bools(bs []bool) <span class="cov8" title="12">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        v, vln, cap := "", 0, ln-cr

        if bs == nil </span><span class="cov1" title="1">{
                w.Raw("null")
                return
        }</span> else<span class="cov7" title="11"> if len(bs) == 0 </span><span class="cov1" title="1">{
                w.Raw("[]")
                return
        }</span> else<span class="cov7" title="10"> if 1+len(bs)*6 &lt;= ln-cr </span><span class="cov3" title="2">{
                bf[cr] = '['
                for _, b := range bs </span><span class="cov5" title="4">{
                        cr++
                        if b </span><span class="cov4" title="3">{
                                v = "true"
                        }</span> else<span class="cov1" title="1"> {
                                v = "false"
                        }</span>
                        <span class="cov5" title="4">cr += copy(bf[cr:], v)
                        bf[cr] = ','</span>
                }
                <span class="cov3" title="2">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov7" title="8"> {
                if ln != cr </span><span class="cov6" title="7">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov1" title="1"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov7" title="8">for _, b := range bs </span><span class="cov10" title="22">{
                        if b </span><span class="cov8" title="15">{
                                v, vln = "true", 4
                        }</span> else<span class="cov6" title="7"> {
                                v, vln = "false", 5
                        }</span>

                        <span class="cov10" title="22">if cap = ln - cr; vln &lt;= cap </span><span class="cov9" title="19">{
                                copy(bf[cr:], v)
                                cr += vln
                        }</span> else<span class="cov4" title="3"> {
                                copy(bf[cr:], v[:cap])
                                w.Storage = append(w.Storage, bf)
                                ln = vln - cap + CHUNK_SIZE
                                bf = make([]byte, ln)
                                cr = copy(bf, v[cap:])
                        }</span>

                        <span class="cov10" title="22">if ln != cr </span><span class="cov9" title="20">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov3" title="2"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }
                <span class="cov7" title="8">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package writer

// ui64dc returns the number of digits of an uint64
func ui64dc(n uint64) (bytes int) <span class="cov10" title="20">{
        if n &lt; 1000000000 </span><span class="cov7" title="9">{
                if n &lt; 100000 </span><span class="cov5" title="5">{
                        if n &lt; 100 </span><span class="cov3" title="2">{
                                if n &lt; 10 </span><span class="cov1" title="1">{
                                        return 1
                                }</span> else<span class="cov1" title="1"> {
                                        return 2
                                }</span>
                        } else<span class="cov4" title="3"> if n &lt; 10000 </span><span class="cov3" title="2">{
                                if n &lt; 1000 </span><span class="cov1" title="1">{
                                        return 3
                                }</span> else<span class="cov1" title="1"> {
                                        return 4
                                }</span>
                        } else<span class="cov1" title="1"> {
                                return 5
                        }</span>
                } else<span class="cov5" title="4"> if n &lt; 10000000 </span><span class="cov3" title="2">{
                        if n &lt; 1000000 </span><span class="cov1" title="1">{
                                return 6
                        }</span> else<span class="cov1" title="1"> {
                                return 7
                        }</span>
                } else<span class="cov3" title="2"> if n &lt; 100000000 </span><span class="cov1" title="1">{
                        return 8
                }</span> else<span class="cov1" title="1"> {
                        return 9
                }</span>
        } else<span class="cov8" title="11"> if n &lt; 100000000000000 </span><span class="cov5" title="5">{
                if n &lt; 100000000000 </span><span class="cov3" title="2">{
                        if n &lt; 10000000000 </span><span class="cov1" title="1">{
                                return 10
                        }</span> else<span class="cov1" title="1"> {
                                return 11
                        }</span>
                } else<span class="cov4" title="3"> if n &lt; 10000000000000 </span><span class="cov3" title="2">{
                        if n &lt; 1000000000000 </span><span class="cov1" title="1">{
                                return 12
                        }</span> else<span class="cov1" title="1"> {
                                return 13
                        }</span>
                } else<span class="cov1" title="1"> {
                        return 14
                }</span>
        } else<span class="cov6" title="6"> if n &lt; 10000000000000000 </span><span class="cov3" title="2">{
                if n &lt; 1000000000000000 </span><span class="cov1" title="1">{
                        return 15
                }</span> else<span class="cov1" title="1"> {
                        return 16
                }</span>
        } else<span class="cov5" title="4"> if n &lt; 1000000000000000000 </span><span class="cov3" title="2">{
                if n &lt; 100000000000000000 </span><span class="cov1" title="1">{
                        return 17
                }</span> else<span class="cov1" title="1"> {
                        return 18
                }</span>
        } else<span class="cov3" title="2"> if n &lt; 10000000000000000000 </span><span class="cov1" title="1">{
                return 19
        }</span> else<span class="cov1" title="1"> {
                return 20
        }</span>
}

// ui32dc returns the number of digits of an uint32
func ui32dc(n uint32) (bytes int) <span class="cov7" title="10">{
        if n &lt; 100000 </span><span class="cov5" title="5">{
                if n &lt; 100 </span><span class="cov3" title="2">{
                        if n &lt; 10 </span><span class="cov1" title="1">{
                                return 1
                        }</span> else<span class="cov1" title="1"> {
                                return 2
                        }</span>
                } else<span class="cov4" title="3"> if n &lt; 10000 </span><span class="cov3" title="2">{
                        if n &lt; 1000 </span><span class="cov1" title="1">{
                                return 3
                        }</span> else<span class="cov1" title="1"> {
                                return 4
                        }</span>
                } else<span class="cov1" title="1"> {
                        return 5
                }</span>
        } else<span class="cov5" title="5"> if n &lt; 10000000 </span><span class="cov3" title="2">{
                if n &lt; 1000000 </span><span class="cov1" title="1">{
                        return 6
                }</span> else<span class="cov1" title="1"> {
                        return 7
                }</span>
        } else<span class="cov4" title="3"> if n &lt; 1000000000 </span><span class="cov3" title="2">{
                if n &lt; 100000000 </span><span class="cov1" title="1">{
                        return 8
                }</span> else<span class="cov1" title="1"> {
                        return 9
                }</span>
        } else<span class="cov1" title="1"> {
                return 10
        }</span>
}

// ui16dc returns the number of digits of an uint16
func ui16dc(n uint16) (bytes int) <span class="cov5" title="5">{
        if n &lt; 100 </span><span class="cov3" title="2">{
                if n &lt; 10 </span><span class="cov1" title="1">{
                        return 1
                }</span> else<span class="cov1" title="1"> {
                        return 2
                }</span>
        } else<span class="cov4" title="3"> if n &lt; 10000 </span><span class="cov3" title="2">{
                if n &lt; 1000 </span><span class="cov1" title="1">{
                        return 3
                }</span> else<span class="cov1" title="1"> {
                        return 4
                }</span>
        } else<span class="cov1" title="1"> {
                return 5
        }</span>
}

// ui8dc returns the number of digits of an uint8
func ui8dc(n uint8) (bytes int) <span class="cov4" title="3">{
        if n &lt; 10 </span><span class="cov1" title="1">{
                return 1
        }</span> else<span class="cov3" title="2"> if n &lt; 100 </span><span class="cov1" title="1">{
                return 2
        }</span> else<span class="cov1" title="1"> {
                return 3
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package writer

import (
        "strconv"
)

func Float32Len(n float32) (bytes int) <span class="cov10" title="17">{
        return 24
}</span>

func Float32pLen(n *float32) (bytes int) <span class="cov3" title="2">{
        if n == nil </span><span class="cov1" title="1">{
                return 4
        }</span> else<span class="cov1" title="1"> {
                return 24
        }</span>
}

func Float32sLen(ns []float32) (bytes int) <span class="cov5" title="4">{
        if ns == nil </span><span class="cov1" title="1">{
                return 4
        }</span> else<span class="cov4" title="3"> if len(ns) == 0 </span><span class="cov1" title="1">{
                return 2
        }</span> else<span class="cov3" title="2"> {
                bytes++
                for range ns </span><span class="cov6" title="5">{
                        bytes += 24 + 1
                }</span>
                <span class="cov3" title="2">return</span>
        }
}

// Writes an 32 bit float to the buffer.
func (w *Writer) Float32(n float32) <span class="cov4" title="3">{
        var vln int
        var dst []byte

        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln = Float32Len(n)
        if vln &lt;= ln-cr </span><span class="cov1" title="1">{
                dst = bf[cr:]
        }</span> else<span class="cov3" title="2"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = 0, dst
        }</span>
        <span class="cov4" title="3">w.Cursor += len(strconv.AppendFloat(dst[:0], float64(n), 'g', -1, 32))</span>
}

// Writes "null" to the buffer when nil, otherwise writes an 32 bit float.
func (w *Writer) Float32p(n *float32) <span class="cov3" title="2">{
        if n == nil </span><span class="cov1" title="1">{
                w.Raw("null")
        }</span> else<span class="cov1" title="1"> {
                w.Float32(*n)
        }</span>
}

// Writes an array of 32 bit float values separated by commas and enclosed
// by square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) Float32s(ns []float32) <span class="cov7" title="9">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov1" title="1">{
                w.Raw("null")
                return
        }</span> else<span class="cov7" title="8"> if len(ns) == 0 </span><span class="cov1" title="1">{
                w.Raw("[]")
                return
        }</span> else<span class="cov7" title="7"> if 1+len(ns)*25 &lt;= ln-cr </span><span class="cov3" title="2">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov5" title="4">{
                        cr++
                        tb := strconv.AppendFloat(bf[:cr], float64(n), 'g', -1, 32)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov3" title="2">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov6" title="5"> {
                if ln != cr </span><span class="cov5" title="4">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov1" title="1"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov6" title="5">for _, n := range ns </span><span class="cov9" title="13">{
                        vln = Float32Len(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov8" title="11">{
                                cr = len(strconv.AppendFloat(bf[:cr], float64(n), 'g', -1, 32))
                        }</span> else<span class="cov3" title="2"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                ln = vln - cap + CHUNK_SIZE
                                bf = make([]byte, ln)
                                cr = len(strconv.AppendFloat(bf[:0], float64(n), 'g', -1, 32))
                        }</span>

                        <span class="cov9" title="13">if ln != cr </span><span class="cov9" title="13">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov6" title="5">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}

func Float64Len(n float64) (bytes int) <span class="cov0" title="0">{
        return 24
}</span>

func Float64pLen(n *float64) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> {
                return 24
        }</span>
}

func Float64sLen(ns []float64) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for range ns </span><span class="cov0" title="0">{
                        bytes += 24 + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes an 64 bit float to the buffer.
func (w *Writer) Float64(n float64) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln = Float64Len(n)
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = 0, dst
        }</span>
        <span class="cov0" title="0">w.Cursor += len(strconv.AppendFloat(dst[:0], float64(n), 'g', -1, 64))</span>
}

// Writes "null" to the buffer when nil, otherwise writes an 64 bit float.
func (w *Writer) Float64p(n *float64) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.Float64(*n)
        }</span>
}

// Writes an array of 64 bit float values separated by commas and enclosed
// by square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) Float64s(ns []float64) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*25 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendFloat(bf[:cr], float64(n), 'g', -1, 64)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = Float64Len(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                cr = len(strconv.AppendFloat(bf[:cr], float64(n), 'g', -1, 64))
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                ln = vln - cap + CHUNK_SIZE
                                bf = make([]byte, ln)
                                cr = len(strconv.AppendFloat(bf[:0], float64(n), 'g', -1, 64))
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package writer

import (
        "strconv"
)

func Int8Len(n int8) (bytes int) <span class="cov0" title="0">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                return ui8dc(uint8(-n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui8dc(uint8(n))
        }</span>
}

func Int8pLen(n *int8) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if *n &lt; 0 </span><span class="cov0" title="0">{
                return ui8dc(uint8(-*n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui8dc(uint8(*n))
        }</span>
}

func Int8sLen(ns []int8) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, n := range ns </span><span class="cov0" title="0">{
                        bytes += Int8Len(n) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an 8 bit integer.
func (w *Writer) Int8p(n *int8) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.Int8(*n)
        }</span>
}

// Writes an 8 bit integer to the buffer.
func (w *Writer) Int8(n int8) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        if n &lt; 0 </span><span class="cov0" title="0">{
                vln = ui8dc(uint8(-n)) + 1
        }</span> else<span class="cov0" title="0"> {
                vln = ui8dc(uint8(n))
        }</span>

        <span class="cov0" title="0">bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

// Writes an array of 8 bit integer values separated by commas and enclosed by
// square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) Int8s(ns []int8) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*5 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendInt(bf[:cr], int64(n), 10)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = Int8Len(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                strconv.AppendInt(bf[:cr], int64(n), 10)
                                cr += vln
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                cr, ln = vln, vln-cap+CHUNK_SIZE
                                bf = make([]byte, ln)
                                strconv.AppendInt(bf[:0], int64(n), 10)
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}

func Int16Len(n int16) (bytes int) <span class="cov0" title="0">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                return ui16dc(uint16(-n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui16dc(uint16(n))
        }</span>
}

func Int16pLen(n *int16) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if *n &lt; 0 </span><span class="cov0" title="0">{
                return ui16dc(uint16(-*n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui16dc(uint16(*n))
        }</span>
}

func Int16sLen(ns []int16) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, n := range ns </span><span class="cov0" title="0">{
                        bytes += Int16Len(n) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an 16 bit integer.
func (w *Writer) Int16p(n *int16) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.Int16(*n)
        }</span>
}

// Writes an 16 bit integer to the buffer.
func (w *Writer) Int16(n int16) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        if n &lt; 0 </span><span class="cov0" title="0">{
                vln = ui16dc(uint16(-n)) + 1
        }</span> else<span class="cov0" title="0"> {
                vln = ui16dc(uint16(n))
        }</span>

        <span class="cov0" title="0">bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

// Writes an array of 16 bit integer values separated by commas and enclosed by
// square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) Int16s(ns []int16) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*7 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendInt(bf[:cr], int64(n), 10)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = Int16Len(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                strconv.AppendInt(bf[:cr], int64(n), 10)
                                cr += vln
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                cr, ln = vln, vln-cap+CHUNK_SIZE
                                bf = make([]byte, ln)
                                strconv.AppendInt(bf[:0], int64(n), 10)
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}

func Int32Len(n int32) (bytes int) <span class="cov0" title="0">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                return ui32dc(uint32(-n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui32dc(uint32(n))
        }</span>
}

func Int32pLen(n *int32) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if *n &lt; 0 </span><span class="cov0" title="0">{
                return ui32dc(uint32(-*n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui32dc(uint32(*n))
        }</span>
}

func Int32sLen(ns []int32) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, n := range ns </span><span class="cov0" title="0">{
                        bytes += Int32Len(n) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an 32 bit integer.
func (w *Writer) Int32p(n *int32) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.Int32(*n)
        }</span>
}

// Writes an 32 bit integer to the buffer.
func (w *Writer) Int32(n int32) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        if n &lt; 0 </span><span class="cov0" title="0">{
                vln = ui32dc(uint32(-n)) + 1
        }</span> else<span class="cov0" title="0"> {
                vln = ui32dc(uint32(n))
        }</span>

        <span class="cov0" title="0">bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

// Writes an array of 32 bit integer values separated by commas and enclosed by
// square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) Int32s(ns []int32) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*12 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendInt(bf[:cr], int64(n), 10)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = Int32Len(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                strconv.AppendInt(bf[:cr], int64(n), 10)
                                cr += vln
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                cr, ln = vln, vln-cap+CHUNK_SIZE
                                bf = make([]byte, ln)
                                strconv.AppendInt(bf[:0], int64(n), 10)
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}

func Int64Len(n int64) (bytes int) <span class="cov0" title="0">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                return ui64dc(-uint64(n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui64dc(-uint64(n))
        }</span>
}

func Int64pLen(n *int64) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if *n &lt; 0 </span><span class="cov0" title="0">{
                return ui64dc(uint64(-*n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui64dc(uint64(*n))
        }</span>
}

func Int64sLen(ns []int64) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, n := range ns </span><span class="cov0" title="0">{
                        bytes += Int64Len(n) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an 64 bit integer.
func (w *Writer) Int64p(n *int64) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.Int64(*n)
        }</span>
}

// Writes an 64 bit integer to the buffer.
func (w *Writer) Int64(n int64) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        if n &lt; 0 </span><span class="cov0" title="0">{
                vln = ui64dc(uint64(-n)) + 1
        }</span> else<span class="cov0" title="0"> {
                vln = ui64dc(uint64(n))
        }</span>

        <span class="cov0" title="0">bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

// Writes an array of 64 bit integer values separated by commas and enclosed by
// square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) Int64s(ns []int64) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*21 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendInt(bf[:cr], int64(n), 10)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = Int64Len(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                strconv.AppendInt(bf[:cr], int64(n), 10)
                                cr += vln
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                cr, ln = vln, vln-cap+CHUNK_SIZE
                                bf = make([]byte, ln)
                                strconv.AppendInt(bf[:0], int64(n), 10)
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}

func IntLen(n int) (bytes int) <span class="cov0" title="0">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                return ui32dc(uint32(-n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui32dc(uint32(n))
        }</span>
}

func IntpLen(n *int) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if *n &lt; 0 </span><span class="cov0" title="0">{
                return ui32dc(uint32(-*n)) + 1
        }</span> else<span class="cov0" title="0"> {
                return ui32dc(uint32(*n))
        }</span>
}

func IntsLen(ns []int) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, n := range ns </span><span class="cov0" title="0">{
                        bytes += IntLen(n) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an integer.
func (w *Writer) Intp(n *int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.Int(*n)
        }</span>
}

// Writes an integer to the buffer.
func (w *Writer) Int(n int) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        if n &lt; 0 </span><span class="cov0" title="0">{
                vln = ui32dc(uint32(-n)) + 1
        }</span> else<span class="cov0" title="0"> {
                vln = ui32dc(uint32(n))
        }</span>

        <span class="cov0" title="0">bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

// Writes an array of integer values separated by commas and enclosed by
// square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) Ints(ns []int) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*12 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendInt(bf[:cr], int64(n), 10)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = IntLen(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                strconv.AppendInt(bf[:cr], int64(n), 10)
                                cr += vln
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                cr, ln = vln, vln-cap+CHUNK_SIZE
                                bf = make([]byte, ln)
                                strconv.AppendInt(bf[:0], int64(n), 10)
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package writer

var escape = []string{
        `\u0000`, `\u0001`, `\u0002`, `\u0003`, `\u0004`, `\u0005`, `\u0006`, `\u0007`,
        `\u0008`, `\t`, `\n`, `\u000B`, `\u000C`, `\r`, `\u000E`, `\u000F`,
        `\u0010`, `\u0011`, `\u0012`, `\u0013`, `\u0014`, `\u0015`, `\u0016`, `\u0017`,
        `\u0018`, `\u0019`, `\u001A`, `\u001B`, `\u001C`, `\u001D`, `\u001E`, `\u001F`,
        "", "", `\"`, "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", `\\`, "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
}

//go:noinline
func (w *Writer) swrite(bfp *[]byte, crp *int, lnp *int, v string) <span class="cov0" title="0">{
        vln, bf, cr, ln := len(v), *bfp, *crp, *lnp
        if vln == 0 </span><span class="cov0" title="0">{
                return
        }</span> else<span class="cov0" title="0"> if cap := ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                cr += copy(bf[cr:], v)
        }</span> else<span class="cov0" title="0"> {
                copy(bf[cr:], v[:cap])
                w.Storage = append(w.Storage, bf)
                ln = vln - cap + CHUNK_SIZE
                bf = make([]byte, ln)
                cr = copy(bf, v[cap:])
        }</span>
        <span class="cov0" title="0">*bfp, *crp, *lnp = bf, cr, ln</span>
}

// Gets the encoded byte length of a string with quotes.
func StringLen(str string) (bytes int, volatile int) <span class="cov0" title="0">{
        return len(str) + 2, len(str)
}</span>

// Gets the encoded byte length of a string pointer with quotes.
func StringpLen(str *string) (bytes int, volatile int) <span class="cov0" title="0">{
        if str == nil </span><span class="cov0" title="0">{
                return 4, 0
        }</span> else<span class="cov0" title="0"> {
                return len(*str) + 2, len(*str)
        }</span>
}

// Gets the encoded byte length of a string slice with brackets, commas and quotes.
func StringsLen(strs []string) (bytes int, volatile int) <span class="cov0" title="0">{
        if strs == nil </span><span class="cov0" title="0">{
                return 4, 0
        }</span> else<span class="cov0" title="0"> if len(strs) == 0 </span><span class="cov0" title="0">{
                return 2, 0
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, s := range strs </span><span class="cov0" title="0">{
                        bytes += len(s) + 3
                        volatile += len(s)
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes a sequence of bytes to the buffer without escaping.
func (w *Writer) Raw(s string) <span class="cov10" title="6">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := len(s), ln-cr

        if vln &lt;= cap </span><span class="cov10" title="6">{
                w.Cursor += copy(bf[cr:], s)
        }</span> else<span class="cov0" title="0"> {
                copy(bf[cr:], s[:cap])
                w.Storage = append(w.Storage, bf)
                bf = make([]byte, vln-cap+CHUNK_SIZE)
                w.Cursor = copy(bf, s[cap:])
                w.Buffer = bf
        }</span>
}

// Writes a single byte to the buffer without escaping.
func (w *Writer) Byte(b byte) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)

        if ln != cr </span><span class="cov0" title="0">{
                bf[cr] = b
                w.Cursor++
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf)
                bf = make([]byte, CHUNK_SIZE)
                bf[0] = b
                w.Cursor, w.Buffer = 1, bf
        }</span>
}

// Writes "null" to the buffer when nil, otherwise writes a string.
func (w *Writer) Stringp(s *string) <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                w.String(*s)
        }</span> else<span class="cov0" title="0"> {
                w.Raw("null")
        }</span>
}

// Writes a string to the buffer with quotes. Special characters are escaped.
func (w *Writer) String(s string) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        beg, vln, cap, esc := 0, 0, 0, ""

        if ln != cr </span><span class="cov0" title="0">{
                bf[cr] = '"'
                cr++
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf)
                cr, ln = 1, CHUNK_SIZE
                bf = make([]byte, CHUNK_SIZE)
                bf[0] = '"'
        }</span>

        <span class="cov0" title="0">for i, c := range s </span><span class="cov0" title="0">{
                if esc = escape[c&amp;0xFF]; esc != "" &amp;&amp; c &lt; 128 </span><span class="cov0" title="0">{
                        w.swrite(&amp;bf, &amp;cr, &amp;ln, s[beg:i])
                        w.swrite(&amp;bf, &amp;cr, &amp;ln, esc)
                        beg = i + 1
                }</span>
        }

        <span class="cov0" title="0">if beg != len(s) </span><span class="cov0" title="0">{
                vln, cap = len(s)-beg, ln-cr
                if vln &lt;= cap </span><span class="cov0" title="0">{
                        cr += copy(bf[cr:], s[beg:])
                }</span> else<span class="cov0" title="0"> {
                        copy(bf[cr:], s[beg:beg+cap])
                        w.Storage = append(w.Storage, bf)
                        ln = vln - cap + CHUNK_SIZE
                        bf = make([]byte, ln)
                        cr = copy(bf, s[beg+cap:])
                }</span>
        }

        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                bf[cr] = '"'
                cr++
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf)
                cr, ln = 1, CHUNK_SIZE
                bf = make([]byte, CHUNK_SIZE)
                bf[0] = '"'
        }</span>
        <span class="cov0" title="0">w.Cursor, w.Buffer = cr, bf</span>
}

// Writes an array of quoted strings separated by commas and enclosed by
// square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) Strings(ss []string) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        cap := ln - cr

        if ss == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ss) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> {
                if 2 &lt;= cap </span><span class="cov0" title="0">{
                        bf[cr], bf[cr+1] = '[', '"'
                        cr += 2
                }</span> else<span class="cov0" title="0"> if cap == 1 </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '"'
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 2, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0], bf[1] = '[', '"'
                }</span>

                <span class="cov0" title="0">beg, vln, esc, s := 0, 0, "", ss[0]
                for i, c := range s </span><span class="cov0" title="0">{
                        if esc = escape[c&amp;0xFF]; esc != "" </span><span class="cov0" title="0">{
                                w.swrite(&amp;bf, &amp;cr, &amp;ln, s[beg:i])
                                w.swrite(&amp;bf, &amp;cr, &amp;ln, esc)
                                beg = i + 1
                        }</span>
                }
                <span class="cov0" title="0">if beg != len(s) </span><span class="cov0" title="0">{
                        w.swrite(&amp;bf, &amp;cr, &amp;ln, s[beg:])
                }</span>

                <span class="cov0" title="0">for _, s := range ss[1:] </span><span class="cov0" title="0">{
                        if cap = ln - cr; 3 &lt;= cap </span><span class="cov0" title="0">{
                                cr += copy(bf[cr:], "\",\"")
                        }</span> else<span class="cov0" title="0"> {
                                copy(bf[cr:], "\",\""[:cap])
                                w.Storage = append(w.Storage, bf)
                                ln = 3 - cap + CHUNK_SIZE
                                bf = make([]byte, ln)
                                cr = copy(bf, "\",\""[cap:])
                        }</span>

                        <span class="cov0" title="0">beg = 0
                        for i, c := range s </span><span class="cov0" title="0">{
                                if esc = escape[c&amp;0xFF]; esc != "" </span><span class="cov0" title="0">{
                                        w.swrite(&amp;bf, &amp;cr, &amp;ln, s[beg:i])
                                        w.swrite(&amp;bf, &amp;cr, &amp;ln, esc)
                                        beg = i + 1
                                }</span>
                        }

                        <span class="cov0" title="0">if beg != len(s) </span><span class="cov0" title="0">{
                                vln, cap = len(s)-beg, ln-cr
                                if vln &lt;= cap </span><span class="cov0" title="0">{
                                        cr += copy(bf[cr:], s[beg:])
                                }</span> else<span class="cov0" title="0"> {
                                        copy(bf[cr:], s[beg:beg+cap])
                                        w.Storage = append(w.Storage, bf)
                                        ln = vln - cap + CHUNK_SIZE
                                        bf = make([]byte, ln)
                                        cr = copy(bf, s[beg+cap:])
                                }</span>
                        }
                }

                <span class="cov0" title="0">if cap = ln - cr; 2 &lt;= cap </span><span class="cov0" title="0">{
                        bf[cr], bf[cr+1] = '"', ']'
                        cr += 2
                }</span> else<span class="cov0" title="0"> if cap == 1 </span><span class="cov0" title="0">{
                        bf[cr] = '"'
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = ']'
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 2, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0], bf[1] = '"', ']'
                }</span>
                <span class="cov0" title="0">w.Cursor, w.Buffer = cr, bf</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package writer

import (
        "time"
)

// Gets the encoded byte length of an RFC3339 time string with quotes.
func TimeLen(t time.Time) (bytes int) <span class="cov0" title="0">{
        nano, nanol := t.Nanosecond(), 10

        if nano &gt; 0 </span><span class="cov0" title="0">{
                for nano%10 == 0 &amp;&amp; nanol &gt; 0 </span><span class="cov0" title="0">{
                        nanol--
                        nano /= 10
                }</span>
        } else<span class="cov0" title="0"> {
                nanol = 0
        }</span>

        <span class="cov0" title="0">_, zone := t.Zone()
        if zone == 0 </span><span class="cov0" title="0">{
                return 22 + nanol
        }</span> else<span class="cov0" title="0"> {
                return 27 + nanol
        }</span>
}

// Gets the encoded byte length of an RFC3339 time string pointer with quotes.
func TimepLen(t *time.Time) (bytes int) <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> {
                return TimeLen(*t)
        }</span>
}

// Gets the encoded byte length of an RFC3339 time string slice with
// brackets, commas and quotes.
func TimesLen(ts []time.Time) (bytes int) <span class="cov0" title="0">{
        if ts == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ts) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, t := range ts </span><span class="cov0" title="0">{
                        bytes += TimeLen(t) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an RFC3339 time string.
func (w *Writer) Timep(t *time.Time) <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                w.Time(*t)
        }</span> else<span class="cov0" title="0"> {
                w.Raw("null")
        }</span>
}

//go:noinline
func (w *Writer) twrite(bfp *[]byte, crp *int, lnp *int, t time.Time) <span class="cov0" title="0">{
        bf, cr, ln := *bfp, *crp, *lnp
        year, month, day := t.Date()
        hour, minute, second := t.Clock()
        nano, nanol := t.Nanosecond(), 10
        zonel, zsig := 1, byte('Z')
        dst := ([]byte)(nil)

        _, zone := t.Zone()
        if zone &gt; 0 </span><span class="cov0" title="0">{
                zonel, zsig = 6, '+'
        }</span> else<span class="cov0" title="0"> if zone &lt; 0 </span><span class="cov0" title="0">{
                zone, zonel, zsig = -zone, 6, '-'
        }</span>

        <span class="cov0" title="0">if nano &gt; 0 </span><span class="cov0" title="0">{
                for nano%10 == 0 &amp;&amp; nanol &gt; 0 </span><span class="cov0" title="0">{
                        nanol--
                        nano /= 10
                }</span>
        } else<span class="cov0" title="0"> {
                nanol = 0
        }</span>

        <span class="cov0" title="0">vln := 19 + nanol + zonel
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                cr += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                cr = vln
                bf = dst
        }</span>

        // Year
        <span class="cov0" title="0">dst[3] = byte(year%10) + '0'
        year /= 10
        dst[2] = byte(year%10) + '0'
        year /= 10
        dst[1] = byte(year%10) + '0'
        year /= 10
        dst[0] = byte(year) + '0'
        // Month
        dst[6] = byte(month%10) + '0'
        month /= 10
        dst[5] = byte(month%10) + '0'
        // Day
        dst[9] = byte(day%10) + '0'
        day /= 10
        dst[8] = byte(day%10) + '0'
        // Hour
        dst[12] = byte(hour%10) + '0'
        hour /= 10
        dst[11] = byte(hour%10) + '0'
        // Minute
        dst[15] = byte(minute%10) + '0'
        minute /= 10
        dst[14] = byte(minute%10) + '0'
        // Second
        dst[18] = byte(second%10) + '0'
        second /= 10
        dst[17] = byte(second%10) + '0'

        // Nanoseconds
        if nano &gt; 0 </span><span class="cov0" title="0">{
                dst[19] = '.'
                for i := nanol + 18; i &gt;= 20; i-- </span><span class="cov0" title="0">{
                        dst[i] = byte(nano%10) + '0'
                        nano /= 10
                }</span>
        }

        // Timezone
        <span class="cov0" title="0">if zone != 0 </span><span class="cov0" title="0">{
                hr, mn := zone/3600, zone%3600
                dst[nanol+24] = byte(mn%600) + '0'
                mn /= 600
                dst[nanol+23] = byte(mn) + '0'
                dst[nanol+22] = ':'
                dst[nanol+21] = byte(hr%10) + '0'
                hr /= 10
                dst[nanol+20] = byte(hr) + '0'
        }</span>

        // Dressing
        <span class="cov0" title="0">dst[4], dst[7], dst[10], dst[13], dst[16] = '-', '-', 'T', ':', ':'
        dst[19+nanol] = zsig
        *bfp, *crp, *lnp = bf, cr, ln</span>
}

// Writes an RFC3339 time string to the buffer with quotes.
func (w *Writer) Time(t time.Time) <span class="cov0" title="0">{
        year, month, day := t.Date()
        hour, minute, second := t.Clock()
        nano, nanol := t.Nanosecond(), 10
        zonel, zsig := 1, byte('Z')
        dst := ([]byte)(nil)

        _, zone := t.Zone()
        if zone &gt; 0 </span><span class="cov0" title="0">{
                zonel, zsig = 6, '+'
        }</span> else<span class="cov0" title="0"> if zone &lt; 0 </span><span class="cov0" title="0">{
                zone, zonel, zsig = -zone, 6, '-'
        }</span>

        <span class="cov0" title="0">if nano &gt; 0 </span><span class="cov0" title="0">{
                for nano%10 == 0 &amp;&amp; nanol &gt; 0 </span><span class="cov0" title="0">{
                        nanol--
                        nano /= 10
                }</span>
        } else<span class="cov0" title="0"> {
                nanol = 0
        }</span>

        <span class="cov0" title="0">bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln := 19 + nanol + zonel + 2
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor = vln
                w.Buffer = dst
        }</span>

        // Year
        <span class="cov0" title="0">dst[4] = byte(year%10) + '0'
        year /= 10
        dst[3] = byte(year%10) + '0'
        year /= 10
        dst[2] = byte(year%10) + '0'
        year /= 10
        dst[1] = byte(year) + '0'
        // Month
        dst[7] = byte(month%10) + '0'
        month /= 10
        dst[6] = byte(month%10) + '0'
        // Day
        dst[10] = byte(day%10) + '0'
        day /= 10
        dst[9] = byte(day%10) + '0'
        // Hour
        dst[13] = byte(hour%10) + '0'
        hour /= 10
        dst[12] = byte(hour%10) + '0'
        // Minute
        dst[16] = byte(minute%10) + '0'
        minute /= 10
        dst[15] = byte(minute%10) + '0'
        // Second
        dst[19] = byte(second%10) + '0'
        second /= 10
        dst[18] = byte(second%10) + '0'

        // Nanoseconds
        if nano &gt; 0 </span><span class="cov0" title="0">{
                dst[20] = '.'
                for i := nanol + 19; i &gt;= 21; i-- </span><span class="cov0" title="0">{
                        dst[i] = byte(nano%10) + '0'
                        nano /= 10
                }</span>
        }

        // Timezone
        <span class="cov0" title="0">if zone != 0 </span><span class="cov0" title="0">{
                hr, mn := zone/3600, zone%3600
                dst[nanol+25] = byte(mn%600) + '0'
                mn /= 600
                dst[nanol+24] = byte(mn) + '0'
                dst[nanol+23] = ':'
                dst[nanol+22] = byte(hr%10) + '0'
                hr /= 10
                dst[nanol+21] = byte(hr) + '0'
        }</span>

        // Dressing
        <span class="cov0" title="0">dst[0], dst[20+nanol+zonel] = '"', '"'
        dst[5], dst[8], dst[11], dst[14], dst[17] = '-', '-', 'T', ':', ':'
        dst[20+nanol] = zsig</span>
}

// Writes an array of RFC3339 time string values separated by commas and enclosed
// by square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) Times(ts []time.Time) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        cap := ln - cr

        if ts == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ts) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ts)*38 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr], bf[cr+1] = '[', '"'
                cr += 2
                w.twrite(&amp;bf, &amp;cr, &amp;ln, ts[0])
                for _, t := range ts[1:] </span><span class="cov0" title="0">{
                        cr += copy(bf[cr:], "\",\"")
                        w.twrite(&amp;bf, &amp;cr, &amp;ln, t)
                }</span>

                <span class="cov0" title="0">bf[cr], bf[cr+1] = '"', ']'
                w.Cursor = cr + 2
                return</span>
        } else<span class="cov0" title="0"> {
                if 2 &lt;= cap </span><span class="cov0" title="0">{
                        bf[cr], bf[cr+1] = '[', '"'
                        cr += 2
                }</span> else<span class="cov0" title="0"> if cap == 1 </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '"'
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 2, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0], bf[1] = '[', '"'
                }</span>

                <span class="cov0" title="0">w.twrite(&amp;bf, &amp;cr, &amp;ln, ts[0])
                for _, t := range ts[1:] </span><span class="cov0" title="0">{
                        if cap = ln - cr; 3 &lt;= cap </span><span class="cov0" title="0">{
                                cr += copy(bf[cr:], "\",\"")
                        }</span> else<span class="cov0" title="0"> {
                                copy(bf[cr:], "\",\""[:cap])
                                w.Storage = append(w.Storage, bf)
                                ln = 3 - cap + CHUNK_SIZE
                                bf = make([]byte, ln)
                                cr = copy(bf, "\",\""[cap:])
                        }</span>
                        <span class="cov0" title="0">w.twrite(&amp;bf, &amp;cr, &amp;ln, t)</span>
                }

                <span class="cov0" title="0">if cap = ln - cr; 2 &lt;= cap </span><span class="cov0" title="0">{
                        bf[cr], bf[cr+1] = '"', ']'
                        cr += 2
                }</span> else<span class="cov0" title="0"> if cap == 1 </span><span class="cov0" title="0">{
                        bf[cr] = '"'
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = ']'
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 2, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0], bf[1] = '"', ']'
                }</span>
                <span class="cov0" title="0">w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package writer

import (
        "encoding/base64"
        "strconv"
)

func UInt8Len(n uint8) (bytes int) <span class="cov0" title="0">{
        return ui8dc(uint8(n))
}</span>

func UInt8pLen(n *uint8) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> {
                return ui8dc(uint8(*n))
        }</span>
}

func UInt8sLen(ns []uint8) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> {
                return (len(ns)+2)/3*4 + 2
        }</span>
}

// Writes "null" to the buffer when nil, otherwise writes an 8 bit unsigned integer.
func (w *Writer) UInt8p(n *uint8) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.UInt8(*n)
        }</span>
}

// Writes an 8 bit unsigned integer to the buffer.
func (w *Writer) UInt8(n uint8) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln = ui8dc(uint8(n))
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

func (w *Writer) UInt8s(ns []uint8) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln := (len(ns)+2)/3*4 + 2

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("\"\"")
                return
        }</span> else<span class="cov0" title="0"> if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                base64.StdEncoding.Encode(bf[cr+1:], ns)
                bf[cr], bf[cr+vln-1] = '"', '"'
                w.Cursor += vln
                return
        }</span> else<span class="cov0" title="0"> if vln-1 == ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '"'
                base64.StdEncoding.Encode(bf[cr+1:], ns)
                w.Storage = append(w.Storage, bf)
                bf = make([]byte, CHUNK_SIZE)
                bf[0] = '"'
                w.Buffer, w.Cursor = bf, 1
                return
        }</span> else<span class="cov0" title="0"> if ln == cr </span><span class="cov0" title="0">{
                w.Storage = append(w.Storage, bf)
                bf = make([]byte, vln+CHUNK_SIZE)
                base64.StdEncoding.Encode(bf[1:], ns)
                bf[0], bf[vln-1] = '"', '"'
                w.Buffer, w.Cursor = bf, vln
                return
        }</span> else<span class="cov0" title="0"> if ln == cr+1 </span><span class="cov0" title="0">{
                bf[cr] = '"'
                w.Storage = append(w.Storage, bf)
                bf = make([]byte, vln+CHUNK_SIZE)
                base64.StdEncoding.Encode(bf, ns)
                bf[vln-2] = '"'
                w.Buffer, w.Cursor = bf, vln
                return
        }</span> else<span class="cov0" title="0"> {
                cap := (ln - cr) / 4
                bcap, dcap := cap*3, cap*4
                ovf := (len(ns) - bcap) * 4

                bf[cr] = '"'
                base64.StdEncoding.Encode(bf[cr+1:], ns[:bcap])
                w.Storage = append(w.Storage, bf[:cr+1+dcap])
                bf = make([]byte, ovf+CHUNK_SIZE)
                base64.StdEncoding.Encode(bf, ns[bcap:])
                bf[ovf] = '"'
                w.Buffer, w.Cursor = bf, ovf+1
                return
        }</span>
}

func UInt16Len(n uint16) (bytes int) <span class="cov0" title="0">{
        return ui16dc(uint16(n))
}</span>

func UInt16pLen(n *uint16) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> {
                return ui16dc(uint16(*n))
        }</span>
}

func UInt16sLen(ns []uint16) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, n := range ns </span><span class="cov0" title="0">{
                        bytes += ui16dc(uint16(n)) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an 16 bit unsigned integer.
func (w *Writer) UInt16p(n *uint16) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.UInt16(*n)
        }</span>
}

// Writes an 16 bit unsigned integer to the buffer.
func (w *Writer) UInt16(n uint16) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln = ui16dc(uint16(n))
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

// Writes an array of 16 bit unsigned integer values separated by commas and enclosed
// by square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) UInt16s(ns []uint16) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*6 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendInt(bf[:cr], int64(n), 10)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = UInt16Len(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                strconv.AppendInt(bf[:cr], int64(n), 10)
                                cr += vln
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                cr, ln = vln, vln-cap+CHUNK_SIZE
                                bf = make([]byte, ln)
                                strconv.AppendInt(bf[:0], int64(n), 10)
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}

func UInt32Len(n uint32) (bytes int) <span class="cov0" title="0">{
        return ui32dc(uint32(n))
}</span>

func UInt32pLen(n *uint32) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> {
                return ui32dc(uint32(*n))
        }</span>
}

func UInt32sLen(ns []uint32) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, n := range ns </span><span class="cov0" title="0">{
                        bytes += ui32dc(uint32(n)) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an 32 bit unsigned integer.
func (w *Writer) UInt32p(n *uint32) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.UInt32(*n)
        }</span>
}

// Writes an 32 bit unsigned integer to the buffer.
func (w *Writer) UInt32(n uint32) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln = ui32dc(uint32(n))
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

// Writes an array of 32 bit unsigned integer values separated by commas and enclosed
// by square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) UInt32s(ns []uint32) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*4 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendInt(bf[:cr], int64(n), 10)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = UInt32Len(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                strconv.AppendInt(bf[:cr], int64(n), 10)
                                cr += vln
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                cr, ln = vln, vln-cap+CHUNK_SIZE
                                bf = make([]byte, ln)
                                strconv.AppendInt(bf[:0], int64(n), 10)
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}

func UInt64Len(n uint64) (bytes int) <span class="cov0" title="0">{
        return ui64dc(uint64(n))
}</span>

func UInt64pLen(n *uint64) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> {
                return ui64dc(uint64(*n))
        }</span>
}

func UInt64sLen(ns []uint64) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, n := range ns </span><span class="cov0" title="0">{
                        bytes += ui64dc(uint64(n)) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an 64 bit unsigned integer.
func (w *Writer) UInt64p(n *uint64) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.UInt64(*n)
        }</span>
}

// Writes an 64 bit unsigned integer to the buffer.
func (w *Writer) UInt64(n uint64) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln = ui64dc(uint64(n))
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

// Writes an array of 64 bit unsigned integer values separated by commas and enclosed
// by square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) UInt64s(ns []uint64) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*21 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendInt(bf[:cr], int64(n), 10)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = UInt64Len(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                strconv.AppendInt(bf[:cr], int64(n), 10)
                                cr += vln
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                cr, ln = vln, vln-cap+CHUNK_SIZE
                                bf = make([]byte, ln)
                                strconv.AppendInt(bf[:0], int64(n), 10)
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}

func UIntLen(n uint) (bytes int) <span class="cov0" title="0">{
        return ui32dc(uint32(n))
}</span>

func UIntpLen(n *uint) (bytes int) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> {
                return ui32dc(uint32(*n))
        }</span>
}

func UIntsLen(ns []uint) (bytes int) <span class="cov0" title="0">{
        if ns == nil </span><span class="cov0" title="0">{
                return 4
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                return 2
        }</span> else<span class="cov0" title="0"> {
                bytes++
                for _, n := range ns </span><span class="cov0" title="0">{
                        bytes += ui32dc(uint32(n)) + 1
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

// Writes "null" to the buffer when nil, otherwise writes an unsigned integer.
func (w *Writer) UIntp(n *uint) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                w.Raw("null")
        }</span> else<span class="cov0" title="0"> {
                w.UInt(*n)
        }</span>
}

// Writes an unsigned integer to the buffer.
func (w *Writer) UInt(n uint) <span class="cov0" title="0">{
        var vln int
        var dst []byte

        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln = ui32dc(uint32(n))
        if vln &lt;= ln-cr </span><span class="cov0" title="0">{
                dst = bf[cr:]
                w.Cursor += vln
        }</span> else<span class="cov0" title="0"> {
                w.Storage = append(w.Storage, bf[:cr])
                dst = make([]byte, vln+CHUNK_SIZE)
                w.Cursor, w.Buffer = vln, dst
        }</span>
        <span class="cov0" title="0">strconv.AppendInt(dst[:0], int64(n), 10)</span>
}

// Writes an array of unsigned integer values separated by commas and enclosed
// by square brackets to the buffer. When the slice is nil, writes "null".
func (w *Writer) UInts(ns []uint) <span class="cov0" title="0">{
        bf := w.Buffer
        cr, ln := w.Cursor, len(bf)
        vln, cap := 0, ln-cr

        if ns == nil </span><span class="cov0" title="0">{
                w.Raw("null")
                return
        }</span> else<span class="cov0" title="0"> if len(ns) == 0 </span><span class="cov0" title="0">{
                w.Raw("[]")
                return
        }</span> else<span class="cov0" title="0"> if 1+len(ns)*12 &lt;= ln-cr </span><span class="cov0" title="0">{
                bf[cr] = '['
                for _, n := range ns </span><span class="cov0" title="0">{
                        cr++
                        tb := strconv.AppendInt(bf[:cr], int64(n), 10)
                        cr = len(tb)
                        bf[cr] = ','
                }</span>

                <span class="cov0" title="0">bf[cr] = ']'
                w.Cursor = cr + 1
                return</span>
        } else<span class="cov0" title="0"> {
                if ln != cr </span><span class="cov0" title="0">{
                        bf[cr] = '['
                        cr++
                }</span> else<span class="cov0" title="0"> {
                        w.Storage = append(w.Storage, bf)
                        cr, ln = 1, CHUNK_SIZE
                        bf = make([]byte, CHUNK_SIZE)
                        bf[0] = '['
                }</span>

                <span class="cov0" title="0">for _, n := range ns </span><span class="cov0" title="0">{
                        vln = UIntLen(n)
                        if cap = ln - cr; vln &lt;= cap </span><span class="cov0" title="0">{
                                strconv.AppendInt(bf[:cr], int64(n), 10)
                                cr += vln
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf[:cr])
                                cr, ln = vln, vln-cap+CHUNK_SIZE
                                bf = make([]byte, ln)
                                strconv.AppendInt(bf[:0], int64(n), 10)
                        }</span>

                        <span class="cov0" title="0">if ln != cr </span><span class="cov0" title="0">{
                                bf[cr] = ','
                                cr++
                        }</span> else<span class="cov0" title="0"> {
                                w.Storage = append(w.Storage, bf)
                                cr, ln = 1, CHUNK_SIZE
                                bf = make([]byte, CHUNK_SIZE)
                                bf[0] = ','
                        }</span>
                }

                <span class="cov0" title="0">bf[cr-1] = ']'
                w.Cursor, w.Buffer = cr, bf
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package writer

const CHUNK_SIZE = 256

type Writer struct {
        Cursor  int
        Buffer  []byte
        Storage [][]byte
}

func NewWriter(length int) *Writer <span class="cov10" title="31">{
        return &amp;Writer{
                Cursor:  0,
                Buffer:  make([]byte, length),
                Storage: [][]byte{},
        }
}</span>

func (w *Writer) Build() (res []byte) <span class="cov10" title="31">{
        ln, beg := w.Cursor, 0
        bf, st := w.Buffer[:ln], w.Storage

        if len(st) == 0 </span><span class="cov8" title="17">{
                return bf
        }</span>

        <span class="cov7" title="14">for _, e := range st </span><span class="cov7" title="14">{
                ln += len(e)
        }</span>

        <span class="cov7" title="14">res = make([]byte, ln)
        for _, e := range st </span><span class="cov7" title="14">{
                copy(res[beg:], e)
                beg += len(e)
        }</span>
        <span class="cov7" title="14">copy(res[beg:], bf)
        return res</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
