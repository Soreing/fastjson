package main

// Writes the header for the source file
func (g *generator) writeHeader() {
	g.buf.WriteString("// Code generated by parsley for scanning JSON strings. DO NOT EDIT.\n")
	g.buf.WriteString("package " + g.pkgName + "\n\n")
}

// Writes imports for the source file
func (g *generator) writeImports(pkgs map[string]string) {
	g.buf.WriteString("import (\n")
	for name, path := range pkgs {
		g.buf.WriteString(name + path + "\n")
	}
	g.buf.WriteString(")\n\n")
	g.buf.WriteString("var _ *reader.Reader\n")
}

// Implements functions for a define and writes it to the buffer
func (g *generator) writeDefine(df define_) {
	name := df.name
	di := newDefineInfo(df)

	code := "func (o *" + name + ")DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {\n" +
		createDecodeDefineBody(di) +
		"    return\n" +
		"}\n\n" +
		"func (o *" + name + ")sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []" + name + ", err error) {\n" +
		"    var e " + name + "\n" +
		"    if err = e.DecodeObjectPJSON(r, filter); err == nil {\n" +
		"        if !r.Next() {\n" +
		"            res = make([]" + name + ", idx+1)\n" +
		"            res[idx] = e\n" +
		"            return\n" +
		"        } else if res, err = o.sequencePJSON(r, filter, idx + 1); err == nil {\n" +
		"            res[idx] = e\n" +
		"        }\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n" +
		"func (o *" + name + ") DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []" + name + ", err error) {\n" +
		"    if err = r.OpenArray(); err == nil {\n" +
		"        if r.Token() == reader.TerminatorToken { \n" +
		"            res = []" + name + "{}\n" +
		"            err = r.CloseArray()\n" +
		"        } else if res, err = o.sequencePJSON(r, filter, 0); err == nil {\n" +
		"            err = r.CloseArray()\n" +
		"        }\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n"

	g.buf.WriteString(code)
}

func (g *generator) writeStruct(st struct_) {
	name := st.name
	fis := []fieldInfo{}
	for _, f := range st.fields {
		fis = append(fis, newFieldInfo(f, g.defaultCase))
	}

	code := "func (o *" + name + ")DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {\n" +
		createFilterHeader(fis) +
		"    var key []byte\n" +
		"    _ = key\n" +
		"    err = r.OpenObject()\n" +
		"    if r.Token() != reader.TerminatorToken {\n" +
		"        for err == nil {\n" +
		"            if key, err = r.Key(); err == nil {\n" +
		"                if r.IsNull() {\n" +
		"                    r.SkipNull()\n" +
		"                } else {\n" +
		createDecodeObjectBody(fis) +
		"                }\n" +
		"                if err == nil && !r.Next() {\n" +
		"                    break\n" +
		"                }\n" +
		"            }\n" +
		"        }\n" +
		"    }\n" +
		"    if err == nil {\n" +
		"        err = r.CloseObject()\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n" +
		"func (o *" + name + ")sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []" + name + ", err error) {\n" +
		"    var e " + name + "\n" +
		"    if err = e.DecodeObjectPJSON(r, filter); err == nil {\n" +
		"        if !r.Next() {\n" +
		"            res = make([]" + name + ", idx+1)\n" +
		"            res[idx] = e\n" +
		"            return\n" +
		"        } else if res, err = o.sequencePJSON(r, filter, idx + 1); err == nil {\n" +
		"            res[idx] = e\n" +
		"        }\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n" +
		"func (o *" + name + ") DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []" + name + ", err error) {\n" +
		"    if err = r.OpenArray(); err == nil {\n" +
		"        if r.Token() == reader.TerminatorToken { \n" +
		"            res = []" + name + "{}\n" +
		"            err = r.CloseArray()\n" +
		"        } else if res, err = o.sequencePJSON(r, filter, 0); err == nil {\n" +
		"            err = r.CloseArray()\n" +
		"        }\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n"

	g.buf.WriteString(code)
}
