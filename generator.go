package parsley

import (
	"bytes"
	"fmt"
	"reflect"
	"regexp"
	"strings"
)

type Case int

const (
	LOWER_CASE Case = iota
	CAMEL_CASE
	PASCAL_CASE
	SNAKE_CASE
	KEBAB_CASE
)

type Generator struct {
	buf         bytes.Buffer
	pkgName     string
	defaultCase Case
}

// Creates a new Generator
func NewGenerator() *Generator {
	return &Generator{
		buf:         bytes.Buffer{},
		pkgName:     "",
		defaultCase: LOWER_CASE,
	}
}

// Sets target package name
func (g *Generator) SetPackage(pkg string) {
	g.pkgName = pkg
}

// Sets default casing of the column names
func (g *Generator) SetDefaultCase(cs Case) {
	g.defaultCase = cs
}

// Writes into the generator's buffer
func (g *Generator) Printf(f string, v ...any) {
	g.buf.WriteString(fmt.Sprintf(f, v...))
}

// Gets the content of the generator's buffer
func (g *Generator) ReadAll() []byte {
	return g.buf.Bytes()
}

// Writes the header for the file
func (g *Generator) WriteHeader() {
	g.buf.WriteString("// Code generated by parsley for scanning JSON strings. DO NOT EDIT.\n")
	g.buf.WriteString("package " + g.pkgName + "\n\n")
}

// Writes the header for the file
func (g *Generator) WriteImports(imp []Import, def []Define, str []Struct) {
	include := map[string]bool{"reader": true}
	for i := range def {
		if def[i].typ.arr && def[i].typ.pkg != "" {
			if _, ok := include[def[i].typ.pkg]; !ok {
				include[def[i].typ.pkg] = true
			}
		}
	}
	for i := range str {
		for j := range str[i].fields {
			t := str[i].fields[j].typ
			if (t.arr || t.ptr) && t.pkg != "" {
				if _, ok := include[t.pkg]; !ok {
					include[t.pkg] = true
				}
			}
		}
	}

	// Exclude time library
	delete(include, "time")

	g.buf.WriteString("import (\n")
	for _, e := range imp {
		if _, ok := include[e.name]; ok {
			g.buf.WriteString("    " + e.name + " " + e.path + "\n")
		}
	}
	g.buf.WriteString(")\n\n")
}

func (g *Generator) ProcessStruct(st Struct) {
	fields := []string{}
	aliases := []string{}
	types := []Type{}

	for _, field := range st.fields {
		alias := parseTag(strings.Trim(field.tag, "`"))
		if alias == "" {
			alias = caseString(field.name, g.defaultCase)
		}
		fields = append(fields, field.name)
		aliases = append(aliases, alias)
		types = append(types, field.typ)
	}

	g.buf.WriteString(
		makeUnmarshalStruct(st.name, fields, aliases, types),
	)
}

func (g *Generator) ProcessDefine(df Define) {
	g.buf.WriteString(
		makeUnmarshalDefine(df.name, df.typ),
	)
}

// Changes a string's casing to the given format
// The string must be in camel or pascal case
func caseString(str string, cs Case) string {
	if str == "" {
		return str
	}

	r, _ := regexp.Compile("[A-Z]?([A-Z]+|[a-z]+)")
	words := r.FindAllString(str, -1)
	for i := 0; i < len(words); i++ {
		words[i] = strings.ToLower(words[i])
	}

	switch cs {
	case LOWER_CASE:
		return strings.Join(words, "")
	case CAMEL_CASE:
		for i := 1; i < len(words); i++ {
			words[i] = strings.ToUpper(words[i][:1]) + words[i][1:]
		}
		return strings.Join(words, "")

	case PASCAL_CASE:
		for i := 0; i < len(words); i++ {
			words[i] = strings.ToUpper(words[i][:1]) + words[i][1:]
		}
		return strings.Join(words, "")
	case SNAKE_CASE:
		return strings.Join(words, "_")
	case KEBAB_CASE:
		return strings.Join(words, "-")
	}

	return str
}

// Parses the struct tag for alias
func parseTag(str string) (alias string) {
	tag := reflect.StructTag(str).Get("json")
	if tag == "" {
		return ""
	}
	tokens := strings.Split(tag, ",")
	return tokens[0]
}

func makeUnmarshalDefine(
	name string,
	typ Type,
) string {
	tn := typ.typ
	if typ.pkg != "" {
		tn = typ.pkg + "." + tn
	}

	fn := ""
	if tmpl, ok := readFnMap[tn]; ok {
		if typ.arr {
			fn = "    *o, err = " + fmt.Sprintf(tmpl, "s") + "\n"
		} else {
			fn = "    *(*" + tn + ")(o), err = " + fmt.Sprintf(tmpl, "") + "\n"
		}
	} else {
		if typ.arr {
			fn = "    *o, err = (*" + tn + ")(nil).UnmarshalParsleyJSONSlice(r)" + "\n"
		} else {
			fn = "    err = o.UnmarshalParsleyJSON(r)" + "\n"
		}
	}

	return "func (o *" + name + ")UnmarshalParsleyJSON(r *reader.Reader) (err error) {\n" +
		fn +
		"    return\n" +
		"}\n\n" +
		"func (o *" + name + ")sequenceParsleyJSON(r *reader.Reader, idx int) (res []" + name + ", err error) {\n" +
		"    var e " + name + "\n" +
		"    if err = e.UnmarshalParsleyJSON(r); err == nil {\n" +
		"        if !r.Next() {\n" +
		"            res = make([]" + name + ", idx+1)\n" +
		"            res[idx] = e\n" +
		"            return\n" +
		"        } else if res, err = o.sequenceParsleyJSON(r, idx + 1); err == nil {\n" +
		"            res[idx] = e\n" +
		"        }\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n" +
		"func (o *" + name + ") UnmarshalParsleyJSONSlice(r *reader.Reader) (res []" + name + ", err error) {\n" +
		"    if err = r.OpenArray(); err == nil {\n" +
		"        if res, err = o.sequenceParsleyJSON(r, 0); err == nil {\n" +
		"            err = r.CloseArray()\n" +
		"        }\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n"
}

func makeUnmarshalStruct(
	name string,
	fields []string,
	aliases []string,
	types []Type,
) string {
	fns := make([]string, len(fields))
	for i, e := range fields {
		tn := types[i].typ
		if types[i].pkg != "" {
			tn = types[i].pkg + "." + tn
		}

		if tmpl, ok := readFnMap[tn]; ok {
			if types[i].arr {
				fns[i] = fmt.Sprintf("                    case \"%s\":\n", aliases[i]) +
					"                        o." + e + ", err = " + fmt.Sprintf(tmpl, "s")
			} else if types[i].ptr {
				fns[i] = fmt.Sprintf("                    case \"%s\":\n", aliases[i]) +
					"                        o." + e + ", err = " + fmt.Sprintf(tmpl, "Ptr")
			} else {
				fns[i] = fmt.Sprintf("                    case \"%s\":\n", aliases[i]) +
					"                        o." + e + ", err = " + fmt.Sprintf(tmpl, "")
			}
		} else {
			if types[i].arr {
				fns[i] = fmt.Sprintf("                    case \"%s\":\n", aliases[i]) +
					"                        o." + e + ", err = (*" + tn + ")(nil).UnmarshalParsleyJSONSlice(r)"
			} else if types[i].ptr {
				fns[i] = fmt.Sprintf("                    case \"%s\":\n", aliases[i]) +
					"                        o." + e + " = &" + tn + "{}\n" +
					"                        err = o." + e + ".UnmarshalParsleyJSON(r)"
			} else {
				fns[i] = fmt.Sprintf("                    case \"%s\":\n", aliases[i]) +
					"                        err = o." + e + ".UnmarshalParsleyJSON(r)"
			}
		}
	}

	return "func (o *" + name + ")UnmarshalParsleyJSON(r *reader.Reader) (err error) {\n" +
		"    var key []byte\n" +
		"    err = r.OpenObject()\n" +
		"    if r.GetType() != reader.TerminatorToken {\n" +
		"        for err == nil {\n" +
		"            if key, err = r.GetKey(); err == nil {\n" +
		"                if r.IsNull() {\n" +
		"                    r.SkipNull()\n" +
		"                } else {\n" +
		"                    switch string(key) {\n" +
		strings.Join(fns, "\n") + "\n" +
		"                    default:\n" +
		"                        err = r.Skip()\n" +
		"                    }\n" +
		"                }\n" +
		"                if err == nil && !r.Next() {\n" +
		"                    break\n" +
		"                }\n" +
		"            }\n" +
		"        }\n" +
		"    }\n" +
		"    if err == nil {\n" +
		"        err = r.CloseObject()\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n" +
		"func (o *" + name + ")sequenceParsleyJSON(r *reader.Reader, idx int) (res []" + name + ", err error) {\n" +
		"    var e " + name + "\n" +
		"    if err = e.UnmarshalParsleyJSON(r); err == nil {\n" +
		"        if !r.Next() {\n" +
		"            res = make([]" + name + ", idx+1)\n" +
		"            res[idx] = e\n" +
		"            return\n" +
		"        } else if res, err = o.sequenceParsleyJSON(r, idx + 1); err == nil {\n" +
		"            res[idx] = e\n" +
		"        }\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n" +
		"func (o *" + name + ") UnmarshalParsleyJSONSlice(r *reader.Reader) (res []" + name + ", err error) {\n" +
		"    if err = r.OpenArray(); err == nil {\n" +
		"        if res, err = o.sequenceParsleyJSON(r, 0); err == nil {\n" +
		"            err = r.CloseArray()\n" +
		"        }\n" +
		"    }\n" +
		"    return\n" +
		"}\n\n"
}

var readFnMap = map[string]string{
	"int":       "r.GetInt%s()",
	"int8":      "r.GetInt8%s()",
	"int16":     "r.GetInt16%s()",
	"int32":     "r.GetInt32%s()",
	"int64":     "r.GetInt64%s()",
	"uint":      "r.GetUInt%s()",
	"uint8":     "r.GetUInt8%s()",
	"uint16":    "r.GetUInt16%s()",
	"uint32":    "r.GetUInt32%s()",
	"uint64":    "r.GetUInt64%s()",
	"float32":   "r.GetFloat32%s()",
	"float64":   "r.GetFloat64%s()",
	"bool":      "r.GetBoolean%s()",
	"string":    "r.GetString%s()",
	"time.Time": "r.GetTime%s()",
}
