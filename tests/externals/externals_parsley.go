// Code generated by parsley for scanning JSON strings. DO NOT EDIT.
package externals

import (
	reader "github.com/Soreing/parsley/reader"
	writer "github.com/Soreing/parsley/writer"
)

var _ *reader.Reader
var _ *writer.Writer

func (o *Device) UnmarshalParsleyJSON(r *reader.Reader) (err error) {
	var key []byte
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					switch string(key) {
					case "name":
						o.Name, err = r.GetString()
					case "type":
						err = o.Type.UnmarshalParsleyJSON(r)
					default:
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *Device) sequenceParsleyJSON(r *reader.Reader, idx int) (res []Device, err error) {
	var e Device
	if err = e.UnmarshalParsleyJSON(r); err == nil {
		if !r.Next() {
			res = make([]Device, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequenceParsleyJSON(r, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *Device) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []Device, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *Device) MarshalParsleyJSON(w *writer.Writer) {
	if o == nil {
		w.Raw("null")
	} else {
		w.Byte('{')
		off := 1
		w.Raw(",\"name\":"[off:])
		w.String(o.Name)
		off = 0
		w.Raw(",\"type\":")
		o.Type.MarshalParsleyJSON(w)
		w.Byte('}')
	}
}

func (o *Device) MarshalParsleyJSONSlice(w *writer.Writer, slc []Device) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].MarshalParsleyJSON(w)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].MarshalParsleyJSON(w)
		}
		w.Byte(']')
	}
}

func (o *Device) LengthParsleyJSON() (ln int) {
	if o == nil {
		return 4
	}
	ln = 18
	if o.Name != "" {
		ln += writer.StringLen(o.Name) - 2
	}
	ln += o.Type.LengthParsleyJSON()
	if ln == 0 {
		return 2
	}
	return ln + 1
}

func (o *Device) LengthParsleyJSONSlice(slc []Device) (ln int) {
	for _, obj := range slc {
		ln += obj.LengthParsleyJSON() + 1
	}
	if ln == 0 {
		return 2
	} else {
		return ln + 1
	}
}

func (o *DeviceType) UnmarshalParsleyJSON(r *reader.Reader) (err error) {
	*(*int)(o), err = r.GetInt()
	return
}

func (o *DeviceType) sequenceParsleyJSON(r *reader.Reader, idx int) (res []DeviceType, err error) {
	var e DeviceType
	if err = e.UnmarshalParsleyJSON(r); err == nil {
		if !r.Next() {
			res = make([]DeviceType, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequenceParsleyJSON(r, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *DeviceType) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []DeviceType, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *DeviceType) MarshalParsleyJSON(w *writer.Writer) {
	if o == nil {
		w.Raw("null")
	}
	w.Int(int(*o))

}

func (o *DeviceType) MarshalParsleyJSONSlice(w *writer.Writer, slc []DeviceType) {
	if slc == nil {
		w.Raw("null")
	}
	w.Byte('[')
	if len(slc) > 0 {
		slc[0].MarshalParsleyJSON(w)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].MarshalParsleyJSON(w)
		}
	}
	w.Byte(']')
}

func (o *DeviceType) LengthParsleyJSON() (ln int) {
	if o == nil {
		return 4
	}
	return writer.IntLen(int(*o))

}

func (o *DeviceType) LengthParsleyJSONSlice(slc []DeviceType) (ln int) {
	for _, obj := range slc {
		ln += obj.LengthParsleyJSON() + 1
	}
	if ln == 0 {
		return 2
	} else {
		return ln + 1
	}
}
