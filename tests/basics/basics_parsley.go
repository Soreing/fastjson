// Code generated by parsley for scanning JSON strings. DO NOT EDIT.
package basics

import (
    reader "github.com/Soreing/parsley/reader"
)

func (o *BooleansColl)UnmarshalParsleyJSON(r *reader.Reader) (err error) {
    var key []byte
    err = r.OpenObject()
    if r.GetType() != reader.TerminatorToken {
        for err == nil {
            if key, err = r.GetKey(); err == nil {
                if r.IsNull() {
                    r.SkipNull()
                } else {
                    switch string(key) {
                    case "bdat":
                        o.BDat, err = r.GetBoolean()
                    case "bslc":
                        o.BSlc, err = r.GetBooleans()
                    case "bptr":
                        o.BPtr, err = r.GetBooleanPtr()
                    default:
                        err = r.Skip()
                    }
                }
                if err == nil && !r.Next() {
                    break
                }
            }
        }
    }
    if err == nil {
        err = r.CloseObject()
    }
    return
}

func (o *BooleansColl)sequenceParsleyJSON(r *reader.Reader, idx int) (res []BooleansColl, err error) {
    var e BooleansColl
    if err = e.UnmarshalParsleyJSON(r); err == nil {
        if !r.Next() {
            res = make([]BooleansColl, idx+1)
            res[idx] = e
            return
        } else if res, err = o.sequenceParsleyJSON(r, idx + 1); err == nil {
            res[idx] = e
        }
    }
    return
}

func (o *BooleansColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []BooleansColl, err error) {
    if err = r.OpenArray(); err == nil {
        if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
            err = r.CloseArray()
        }
    }
    return
}

func (o *FloatingPointColl)UnmarshalParsleyJSON(r *reader.Reader) (err error) {
    var key []byte
    err = r.OpenObject()
    if r.GetType() != reader.TerminatorToken {
        for err == nil {
            if key, err = r.GetKey(); err == nil {
                if r.IsNull() {
                    r.SkipNull()
                } else {
                    switch string(key) {
                    case "f32dat":
                        o.F32Dat, err = r.GetFloat32()
                    case "f32slc":
                        o.F32Slc, err = r.GetFloat32s()
                    case "f32ptr":
                        o.F32Ptr, err = r.GetFloat32Ptr()
                    case "f64dat":
                        o.F64Dat, err = r.GetFloat64()
                    case "f64slc":
                        o.F64Slc, err = r.GetFloat64s()
                    case "f64ptr":
                        o.F64Ptr, err = r.GetFloat64Ptr()
                    default:
                        err = r.Skip()
                    }
                }
                if err == nil && !r.Next() {
                    break
                }
            }
        }
    }
    if err == nil {
        err = r.CloseObject()
    }
    return
}

func (o *FloatingPointColl)sequenceParsleyJSON(r *reader.Reader, idx int) (res []FloatingPointColl, err error) {
    var e FloatingPointColl
    if err = e.UnmarshalParsleyJSON(r); err == nil {
        if !r.Next() {
            res = make([]FloatingPointColl, idx+1)
            res[idx] = e
            return
        } else if res, err = o.sequenceParsleyJSON(r, idx + 1); err == nil {
            res[idx] = e
        }
    }
    return
}

func (o *FloatingPointColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []FloatingPointColl, err error) {
    if err = r.OpenArray(); err == nil {
        if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
            err = r.CloseArray()
        }
    }
    return
}

func (o *IntegersColl)UnmarshalParsleyJSON(r *reader.Reader) (err error) {
    var key []byte
    err = r.OpenObject()
    if r.GetType() != reader.TerminatorToken {
        for err == nil {
            if key, err = r.GetKey(); err == nil {
                if r.IsNull() {
                    r.SkipNull()
                } else {
                    switch string(key) {
                    case "i8dat":
                        o.I8Dat, err = r.GetInt8()
                    case "i8slc":
                        o.I8Slc, err = r.GetInt8s()
                    case "i8ptr":
                        o.I8Ptr, err = r.GetInt8Ptr()
                    case "i16dat":
                        o.I16Dat, err = r.GetInt16()
                    case "i16slc":
                        o.I16Slc, err = r.GetInt16s()
                    case "i16ptr":
                        o.I16Ptr, err = r.GetInt16Ptr()
                    case "i32dat":
                        o.I32Dat, err = r.GetInt32()
                    case "i32slc":
                        o.I32Slc, err = r.GetInt32s()
                    case "i32ptr":
                        o.I32Ptr, err = r.GetInt32Ptr()
                    case "i64dat":
                        o.I64Dat, err = r.GetInt64()
                    case "i64slc":
                        o.I64Slc, err = r.GetInt64s()
                    case "i64ptr":
                        o.I64Ptr, err = r.GetInt64Ptr()
                    case "idat":
                        o.IDat, err = r.GetInt()
                    case "islc":
                        o.ISlc, err = r.GetInts()
                    case "iptr":
                        o.IPtr, err = r.GetIntPtr()
                    default:
                        err = r.Skip()
                    }
                }
                if err == nil && !r.Next() {
                    break
                }
            }
        }
    }
    if err == nil {
        err = r.CloseObject()
    }
    return
}

func (o *IntegersColl)sequenceParsleyJSON(r *reader.Reader, idx int) (res []IntegersColl, err error) {
    var e IntegersColl
    if err = e.UnmarshalParsleyJSON(r); err == nil {
        if !r.Next() {
            res = make([]IntegersColl, idx+1)
            res[idx] = e
            return
        } else if res, err = o.sequenceParsleyJSON(r, idx + 1); err == nil {
            res[idx] = e
        }
    }
    return
}

func (o *IntegersColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []IntegersColl, err error) {
    if err = r.OpenArray(); err == nil {
        if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
            err = r.CloseArray()
        }
    }
    return
}

func (o *StringsColl)UnmarshalParsleyJSON(r *reader.Reader) (err error) {
    var key []byte
    err = r.OpenObject()
    if r.GetType() != reader.TerminatorToken {
        for err == nil {
            if key, err = r.GetKey(); err == nil {
                if r.IsNull() {
                    r.SkipNull()
                } else {
                    switch string(key) {
                    case "sdat":
                        o.SDat, err = r.GetString()
                    case "sslc":
                        o.SSlc, err = r.GetStrings()
                    case "sptr":
                        o.SPtr, err = r.GetStringPtr()
                    case "tdat":
                        o.TDat, err = r.GetTime()
                    case "tslc":
                        o.TSlc, err = r.GetTimes()
                    case "tptr":
                        o.TPtr, err = r.GetTimePtr()
                    default:
                        err = r.Skip()
                    }
                }
                if err == nil && !r.Next() {
                    break
                }
            }
        }
    }
    if err == nil {
        err = r.CloseObject()
    }
    return
}

func (o *StringsColl)sequenceParsleyJSON(r *reader.Reader, idx int) (res []StringsColl, err error) {
    var e StringsColl
    if err = e.UnmarshalParsleyJSON(r); err == nil {
        if !r.Next() {
            res = make([]StringsColl, idx+1)
            res[idx] = e
            return
        } else if res, err = o.sequenceParsleyJSON(r, idx + 1); err == nil {
            res[idx] = e
        }
    }
    return
}

func (o *StringsColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []StringsColl, err error) {
    if err = r.OpenArray(); err == nil {
        if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
            err = r.CloseArray()
        }
    }
    return
}

func (o *UnsignedIntegersColl)UnmarshalParsleyJSON(r *reader.Reader) (err error) {
    var key []byte
    err = r.OpenObject()
    if r.GetType() != reader.TerminatorToken {
        for err == nil {
            if key, err = r.GetKey(); err == nil {
                if r.IsNull() {
                    r.SkipNull()
                } else {
                    switch string(key) {
                    case "ui8dat":
                        o.UI8Dat, err = r.GetUInt8()
                    case "ui8slc":
                        o.UI8Slc, err = r.GetUInt8s()
                    case "ui8ptr":
                        o.UI8Ptr, err = r.GetUInt8Ptr()
                    case "ui16dat":
                        o.UI16Dat, err = r.GetUInt16()
                    case "ui16slc":
                        o.UI16Slc, err = r.GetUInt16s()
                    case "ui16ptr":
                        o.UI16Ptr, err = r.GetUInt16Ptr()
                    case "ui32dat":
                        o.UI32Dat, err = r.GetUInt32()
                    case "ui32slc":
                        o.UI32Slc, err = r.GetUInt32s()
                    case "ui32ptr":
                        o.UI32Ptr, err = r.GetUInt32Ptr()
                    case "ui64dat":
                        o.UI64Dat, err = r.GetUInt64()
                    case "ui64slc":
                        o.UI64Slc, err = r.GetUInt64s()
                    case "ui64ptr":
                        o.UI64Ptr, err = r.GetUInt64Ptr()
                    case "uidat":
                        o.UIDat, err = r.GetUInt()
                    case "uislc":
                        o.UISlc, err = r.GetUInts()
                    case "uiptr":
                        o.UIPtr, err = r.GetUIntPtr()
                    default:
                        err = r.Skip()
                    }
                }
                if err == nil && !r.Next() {
                    break
                }
            }
        }
    }
    if err == nil {
        err = r.CloseObject()
    }
    return
}

func (o *UnsignedIntegersColl)sequenceParsleyJSON(r *reader.Reader, idx int) (res []UnsignedIntegersColl, err error) {
    var e UnsignedIntegersColl
    if err = e.UnmarshalParsleyJSON(r); err == nil {
        if !r.Next() {
            res = make([]UnsignedIntegersColl, idx+1)
            res[idx] = e
            return
        } else if res, err = o.sequenceParsleyJSON(r, idx + 1); err == nil {
            res[idx] = e
        }
    }
    return
}

func (o *UnsignedIntegersColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []UnsignedIntegersColl, err error) {
    if err = r.OpenArray(); err == nil {
        if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
            err = r.CloseArray()
        }
    }
    return
}

