// Code generated by parsley for scanning JSON strings. DO NOT EDIT.
package basics

import (
	parse "github.com/Soreing/parsley"
	reader "github.com/Soreing/parsley/reader"
)

var _ *reader.Reader

func (o *BooleansColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [3]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "bdat" {
				c[0] = true
			} else if k == "bslc" {
				c[1] = true
			} else if k == "bptr" {
				c[2] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "bdat" && c[0] {
						o.BDat, err = r.Bool()
					} else if string(key) == "bslc" && c[1] {
						o.BSlc, err = r.Bools()
					} else if string(key) == "bptr" && c[2] {
						o.BPtr, err = r.Boolp()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *BooleansColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []BooleansColl, err error) {
	var e BooleansColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]BooleansColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *BooleansColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []BooleansColl, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []BooleansColl{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *FloatingPointColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [6]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "f32dat" {
				c[0] = true
			} else if k == "f32slc" {
				c[1] = true
			} else if k == "f32ptr" {
				c[2] = true
			} else if k == "f64dat" {
				c[3] = true
			} else if k == "f64slc" {
				c[4] = true
			} else if k == "f64ptr" {
				c[5] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "f32dat" && c[0] {
						o.F32Dat, err = r.Float32()
					} else if string(key) == "f32slc" && c[1] {
						o.F32Slc, err = r.Float32s()
					} else if string(key) == "f32ptr" && c[2] {
						o.F32Ptr, err = r.Float32p()
					} else if string(key) == "f64dat" && c[3] {
						o.F64Dat, err = r.Float64()
					} else if string(key) == "f64slc" && c[4] {
						o.F64Slc, err = r.Float64s()
					} else if string(key) == "f64ptr" && c[5] {
						o.F64Ptr, err = r.Float64p()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *FloatingPointColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []FloatingPointColl, err error) {
	var e FloatingPointColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]FloatingPointColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *FloatingPointColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []FloatingPointColl, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []FloatingPointColl{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *IntegersColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [15]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "i8dat" {
				c[0] = true
			} else if k == "i8slc" {
				c[1] = true
			} else if k == "i8ptr" {
				c[2] = true
			} else if k == "i16dat" {
				c[3] = true
			} else if k == "i16slc" {
				c[4] = true
			} else if k == "i16ptr" {
				c[5] = true
			} else if k == "i32dat" {
				c[6] = true
			} else if k == "i32slc" {
				c[7] = true
			} else if k == "i32ptr" {
				c[8] = true
			} else if k == "i64dat" {
				c[9] = true
			} else if k == "i64slc" {
				c[10] = true
			} else if k == "i64ptr" {
				c[11] = true
			} else if k == "idat" {
				c[12] = true
			} else if k == "islc" {
				c[13] = true
			} else if k == "iptr" {
				c[14] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "i8dat" && c[0] {
						o.I8Dat, err = r.Int8()
					} else if string(key) == "i8slc" && c[1] {
						o.I8Slc, err = r.Int8s()
					} else if string(key) == "i8ptr" && c[2] {
						o.I8Ptr, err = r.Int8p()
					} else if string(key) == "i16dat" && c[3] {
						o.I16Dat, err = r.Int16()
					} else if string(key) == "i16slc" && c[4] {
						o.I16Slc, err = r.Int16s()
					} else if string(key) == "i16ptr" && c[5] {
						o.I16Ptr, err = r.Int16p()
					} else if string(key) == "i32dat" && c[6] {
						o.I32Dat, err = r.Int32()
					} else if string(key) == "i32slc" && c[7] {
						o.I32Slc, err = r.Int32s()
					} else if string(key) == "i32ptr" && c[8] {
						o.I32Ptr, err = r.Int32p()
					} else if string(key) == "i64dat" && c[9] {
						o.I64Dat, err = r.Int64()
					} else if string(key) == "i64slc" && c[10] {
						o.I64Slc, err = r.Int64s()
					} else if string(key) == "i64ptr" && c[11] {
						o.I64Ptr, err = r.Int64p()
					} else if string(key) == "idat" && c[12] {
						o.IDat, err = r.Int()
					} else if string(key) == "islc" && c[13] {
						o.ISlc, err = r.Ints()
					} else if string(key) == "iptr" && c[14] {
						o.IPtr, err = r.Intp()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *IntegersColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []IntegersColl, err error) {
	var e IntegersColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]IntegersColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *IntegersColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []IntegersColl, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []IntegersColl{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *StringsColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [6]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "sdat" {
				c[0] = true
			} else if k == "sslc" {
				c[1] = true
			} else if k == "sptr" {
				c[2] = true
			} else if k == "tdat" {
				c[3] = true
			} else if k == "tslc" {
				c[4] = true
			} else if k == "tptr" {
				c[5] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "sdat" && c[0] {
						o.SDat, err = r.String()
					} else if string(key) == "sslc" && c[1] {
						o.SSlc, err = r.Strings()
					} else if string(key) == "sptr" && c[2] {
						o.SPtr, err = r.Stringp()
					} else if string(key) == "tdat" && c[3] {
						o.TDat, err = r.Time()
					} else if string(key) == "tslc" && c[4] {
						o.TSlc, err = r.Times()
					} else if string(key) == "tptr" && c[5] {
						o.TPtr, err = r.Timep()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *StringsColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []StringsColl, err error) {
	var e StringsColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]StringsColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *StringsColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []StringsColl, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []StringsColl{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *UnsignedIntegersColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [15]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "ui8dat" {
				c[0] = true
			} else if k == "ui8slc" {
				c[1] = true
			} else if k == "ui8ptr" {
				c[2] = true
			} else if k == "ui16dat" {
				c[3] = true
			} else if k == "ui16slc" {
				c[4] = true
			} else if k == "ui16ptr" {
				c[5] = true
			} else if k == "ui32dat" {
				c[6] = true
			} else if k == "ui32slc" {
				c[7] = true
			} else if k == "ui32ptr" {
				c[8] = true
			} else if k == "ui64dat" {
				c[9] = true
			} else if k == "ui64slc" {
				c[10] = true
			} else if k == "ui64ptr" {
				c[11] = true
			} else if k == "uidat" {
				c[12] = true
			} else if k == "uislc" {
				c[13] = true
			} else if k == "uiptr" {
				c[14] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "ui8dat" && c[0] {
						o.UI8Dat, err = r.UInt8()
					} else if string(key) == "ui8slc" && c[1] {
						o.UI8Slc, err = r.UInt8s()
					} else if string(key) == "ui8ptr" && c[2] {
						o.UI8Ptr, err = r.UInt8p()
					} else if string(key) == "ui16dat" && c[3] {
						o.UI16Dat, err = r.UInt16()
					} else if string(key) == "ui16slc" && c[4] {
						o.UI16Slc, err = r.UInt16s()
					} else if string(key) == "ui16ptr" && c[5] {
						o.UI16Ptr, err = r.UInt16p()
					} else if string(key) == "ui32dat" && c[6] {
						o.UI32Dat, err = r.UInt32()
					} else if string(key) == "ui32slc" && c[7] {
						o.UI32Slc, err = r.UInt32s()
					} else if string(key) == "ui32ptr" && c[8] {
						o.UI32Ptr, err = r.UInt32p()
					} else if string(key) == "ui64dat" && c[9] {
						o.UI64Dat, err = r.UInt64()
					} else if string(key) == "ui64slc" && c[10] {
						o.UI64Slc, err = r.UInt64s()
					} else if string(key) == "ui64ptr" && c[11] {
						o.UI64Ptr, err = r.UInt64p()
					} else if string(key) == "uidat" && c[12] {
						o.UIDat, err = r.UInt()
					} else if string(key) == "uislc" && c[13] {
						o.UISlc, err = r.UInts()
					} else if string(key) == "uiptr" && c[14] {
						o.UIPtr, err = r.UIntp()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *UnsignedIntegersColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []UnsignedIntegersColl, err error) {
	var e UnsignedIntegersColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]UnsignedIntegersColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *UnsignedIntegersColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []UnsignedIntegersColl, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []UnsignedIntegersColl{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}
