// Code generated by parsley for scanning JSON strings. DO NOT EDIT.
package basics

import (
	parse "github.com/Soreing/parsley"
	reader "github.com/Soreing/parsley/reader"
	writer "github.com/Soreing/parsley/writer"
)

var _ *reader.Reader
var _ *writer.Writer

func (o *BooleansColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [3]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "bdat" {
				c[0] = true
			} else if k == "bslc" {
				c[1] = true
			} else if k == "bptr" {
				c[2] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "bdat" && c[0] {
						o.BDat, err = r.GetBool()
					} else if string(key) == "bslc" && c[1] {
						o.BSlc, err = r.GetBools()
					} else if string(key) == "bptr" && c[2] {
						o.BPtr, err = r.GetBoolPtr()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *BooleansColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []BooleansColl, err error) {
	var e BooleansColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]BooleansColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *BooleansColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []BooleansColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *BooleansColl) EncodeObjectPJSON(w *writer.Writer, filter []parse.Filter) {
	if o == nil {
		w.Raw("null")
	} else {
		c := [3]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "bdat" {
					c[0] = true
				} else if k == "bslc" {
					c[1] = true
				} else if k == "bptr" {
					c[2] = true
				}
			}
		}
		w.Byte('{')
		off := 1
		if c[0] {
			w.Raw(",\"bdat\":"[off:])
			w.Bool(o.BDat)
			off = 0
		}
		if c[1] {
			w.Raw(",\"bslc\":"[off:])
			w.Bools(o.BSlc)
			off = 0
		}
		if c[2] {
			w.Raw(",\"bptr\":"[off:])
			w.Boolp(o.BPtr)
			off = 0
		}
		w.Byte('}')
	}
}

func (o *BooleansColl) EncodeSlicePJSON(w *writer.Writer, filter []parse.Filter, slc []BooleansColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].EncodeObjectPJSON(w, filter)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].EncodeObjectPJSON(w, filter)
		}
		w.Byte(']')
	}
}

func (o *BooleansColl) ObjectLengthPJSON(filter []parse.Filter) (bytes int, volatile int) {
	if o == nil {
		return 4, 0
	} else {
		c := [3]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "bdat" {
					c[0] = true
				} else if k == "bslc" {
					c[1] = true
				} else if k == "bptr" {
					c[2] = true
				}
			}
		}
		if c[0] {
			bytes += writer.BoolLen(o.BDat) + 8
		}
		if c[1] {
			bytes += writer.BoolsLen(o.BSlc) + 8
		}
		if c[2] {
			bytes += writer.BoolpLen(o.BPtr) + 8
		}
		if bytes == 0 {
			return 2, 0
		} else {
			return bytes + 1, volatile
		}
	}
}

func (o *BooleansColl) SliceLengthPJSON(filter []parse.Filter, slc []BooleansColl) (bytes int, volatile int) {
	for _, obj := range slc {
		b, v := obj.ObjectLengthPJSON(filter)
		bytes, volatile = bytes+b+1, volatile+v
	}
	if bytes == 0 {
		return 2, 0
	} else {
		return bytes + 1, volatile
	}
}

func (o *FloatingPointColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [6]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "f32dat" {
				c[0] = true
			} else if k == "f32slc" {
				c[1] = true
			} else if k == "f32ptr" {
				c[2] = true
			} else if k == "f64dat" {
				c[3] = true
			} else if k == "f64slc" {
				c[4] = true
			} else if k == "f64ptr" {
				c[5] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "f32dat" && c[0] {
						o.F32Dat, err = r.GetFloat32()
					} else if string(key) == "f32slc" && c[1] {
						o.F32Slc, err = r.GetFloat32s()
					} else if string(key) == "f32ptr" && c[2] {
						o.F32Ptr, err = r.GetFloat32Ptr()
					} else if string(key) == "f64dat" && c[3] {
						o.F64Dat, err = r.GetFloat64()
					} else if string(key) == "f64slc" && c[4] {
						o.F64Slc, err = r.GetFloat64s()
					} else if string(key) == "f64ptr" && c[5] {
						o.F64Ptr, err = r.GetFloat64Ptr()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *FloatingPointColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []FloatingPointColl, err error) {
	var e FloatingPointColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]FloatingPointColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *FloatingPointColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []FloatingPointColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *FloatingPointColl) EncodeObjectPJSON(w *writer.Writer, filter []parse.Filter) {
	if o == nil {
		w.Raw("null")
	} else {
		c := [6]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "f32dat" {
					c[0] = true
				} else if k == "f32slc" {
					c[1] = true
				} else if k == "f32ptr" {
					c[2] = true
				} else if k == "f64dat" {
					c[3] = true
				} else if k == "f64slc" {
					c[4] = true
				} else if k == "f64ptr" {
					c[5] = true
				}
			}
		}
		w.Byte('{')
		off := 1
		if c[0] {
			w.Raw(",\"f32dat\":"[off:])
			w.Float32(o.F32Dat)
			off = 0
		}
		if c[1] {
			w.Raw(",\"f32slc\":"[off:])
			w.Float32s(o.F32Slc)
			off = 0
		}
		if c[2] {
			w.Raw(",\"f32ptr\":"[off:])
			w.Float32p(o.F32Ptr)
			off = 0
		}
		if c[3] {
			w.Raw(",\"f64dat\":"[off:])
			w.Float64(o.F64Dat)
			off = 0
		}
		if c[4] {
			w.Raw(",\"f64slc\":"[off:])
			w.Float64s(o.F64Slc)
			off = 0
		}
		if c[5] {
			w.Raw(",\"f64ptr\":"[off:])
			w.Float64p(o.F64Ptr)
			off = 0
		}
		w.Byte('}')
	}
}

func (o *FloatingPointColl) EncodeSlicePJSON(w *writer.Writer, filter []parse.Filter, slc []FloatingPointColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].EncodeObjectPJSON(w, filter)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].EncodeObjectPJSON(w, filter)
		}
		w.Byte(']')
	}
}

func (o *FloatingPointColl) ObjectLengthPJSON(filter []parse.Filter) (bytes int, volatile int) {
	if o == nil {
		return 4, 0
	} else {
		c := [6]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "f32dat" {
					c[0] = true
				} else if k == "f32slc" {
					c[1] = true
				} else if k == "f32ptr" {
					c[2] = true
				} else if k == "f64dat" {
					c[3] = true
				} else if k == "f64slc" {
					c[4] = true
				} else if k == "f64ptr" {
					c[5] = true
				}
			}
		}
		if c[0] {
			bytes += writer.Float32Len(o.F32Dat) + 10
		}
		if c[1] {
			bytes += writer.Float32sLen(o.F32Slc) + 10
		}
		if c[2] {
			bytes += writer.Float32pLen(o.F32Ptr) + 10
		}
		if c[3] {
			bytes += writer.Float64Len(o.F64Dat) + 10
		}
		if c[4] {
			bytes += writer.Float64sLen(o.F64Slc) + 10
		}
		if c[5] {
			bytes += writer.Float64pLen(o.F64Ptr) + 10
		}
		if bytes == 0 {
			return 2, 0
		} else {
			return bytes + 1, volatile
		}
	}
}

func (o *FloatingPointColl) SliceLengthPJSON(filter []parse.Filter, slc []FloatingPointColl) (bytes int, volatile int) {
	for _, obj := range slc {
		b, v := obj.ObjectLengthPJSON(filter)
		bytes, volatile = bytes+b+1, volatile+v
	}
	if bytes == 0 {
		return 2, 0
	} else {
		return bytes + 1, volatile
	}
}

func (o *IntegersColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [15]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "i8dat" {
				c[0] = true
			} else if k == "i8slc" {
				c[1] = true
			} else if k == "i8ptr" {
				c[2] = true
			} else if k == "i16dat" {
				c[3] = true
			} else if k == "i16slc" {
				c[4] = true
			} else if k == "i16ptr" {
				c[5] = true
			} else if k == "i32dat" {
				c[6] = true
			} else if k == "i32slc" {
				c[7] = true
			} else if k == "i32ptr" {
				c[8] = true
			} else if k == "i64dat" {
				c[9] = true
			} else if k == "i64slc" {
				c[10] = true
			} else if k == "i64ptr" {
				c[11] = true
			} else if k == "idat" {
				c[12] = true
			} else if k == "islc" {
				c[13] = true
			} else if k == "iptr" {
				c[14] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "i8dat" && c[0] {
						o.I8Dat, err = r.GetInt8()
					} else if string(key) == "i8slc" && c[1] {
						o.I8Slc, err = r.GetInt8s()
					} else if string(key) == "i8ptr" && c[2] {
						o.I8Ptr, err = r.GetInt8Ptr()
					} else if string(key) == "i16dat" && c[3] {
						o.I16Dat, err = r.GetInt16()
					} else if string(key) == "i16slc" && c[4] {
						o.I16Slc, err = r.GetInt16s()
					} else if string(key) == "i16ptr" && c[5] {
						o.I16Ptr, err = r.GetInt16Ptr()
					} else if string(key) == "i32dat" && c[6] {
						o.I32Dat, err = r.GetInt32()
					} else if string(key) == "i32slc" && c[7] {
						o.I32Slc, err = r.GetInt32s()
					} else if string(key) == "i32ptr" && c[8] {
						o.I32Ptr, err = r.GetInt32Ptr()
					} else if string(key) == "i64dat" && c[9] {
						o.I64Dat, err = r.GetInt64()
					} else if string(key) == "i64slc" && c[10] {
						o.I64Slc, err = r.GetInt64s()
					} else if string(key) == "i64ptr" && c[11] {
						o.I64Ptr, err = r.GetInt64Ptr()
					} else if string(key) == "idat" && c[12] {
						o.IDat, err = r.GetInt()
					} else if string(key) == "islc" && c[13] {
						o.ISlc, err = r.GetInts()
					} else if string(key) == "iptr" && c[14] {
						o.IPtr, err = r.GetIntPtr()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *IntegersColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []IntegersColl, err error) {
	var e IntegersColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]IntegersColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *IntegersColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []IntegersColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *IntegersColl) EncodeObjectPJSON(w *writer.Writer, filter []parse.Filter) {
	if o == nil {
		w.Raw("null")
	} else {
		c := [15]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "i8dat" {
					c[0] = true
				} else if k == "i8slc" {
					c[1] = true
				} else if k == "i8ptr" {
					c[2] = true
				} else if k == "i16dat" {
					c[3] = true
				} else if k == "i16slc" {
					c[4] = true
				} else if k == "i16ptr" {
					c[5] = true
				} else if k == "i32dat" {
					c[6] = true
				} else if k == "i32slc" {
					c[7] = true
				} else if k == "i32ptr" {
					c[8] = true
				} else if k == "i64dat" {
					c[9] = true
				} else if k == "i64slc" {
					c[10] = true
				} else if k == "i64ptr" {
					c[11] = true
				} else if k == "idat" {
					c[12] = true
				} else if k == "islc" {
					c[13] = true
				} else if k == "iptr" {
					c[14] = true
				}
			}
		}
		w.Byte('{')
		off := 1
		if c[0] {
			w.Raw(",\"i8dat\":"[off:])
			w.Int8(o.I8Dat)
			off = 0
		}
		if c[1] {
			w.Raw(",\"i8slc\":"[off:])
			w.Int8s(o.I8Slc)
			off = 0
		}
		if c[2] {
			w.Raw(",\"i8ptr\":"[off:])
			w.Int8p(o.I8Ptr)
			off = 0
		}
		if c[3] {
			w.Raw(",\"i16dat\":"[off:])
			w.Int16(o.I16Dat)
			off = 0
		}
		if c[4] {
			w.Raw(",\"i16slc\":"[off:])
			w.Int16s(o.I16Slc)
			off = 0
		}
		if c[5] {
			w.Raw(",\"i16ptr\":"[off:])
			w.Int16p(o.I16Ptr)
			off = 0
		}
		if c[6] {
			w.Raw(",\"i32dat\":"[off:])
			w.Int32(o.I32Dat)
			off = 0
		}
		if c[7] {
			w.Raw(",\"i32slc\":"[off:])
			w.Int32s(o.I32Slc)
			off = 0
		}
		if c[8] {
			w.Raw(",\"i32ptr\":"[off:])
			w.Int32p(o.I32Ptr)
			off = 0
		}
		if c[9] {
			w.Raw(",\"i64dat\":"[off:])
			w.Int64(o.I64Dat)
			off = 0
		}
		if c[10] {
			w.Raw(",\"i64slc\":"[off:])
			w.Int64s(o.I64Slc)
			off = 0
		}
		if c[11] {
			w.Raw(",\"i64ptr\":"[off:])
			w.Int64p(o.I64Ptr)
			off = 0
		}
		if c[12] {
			w.Raw(",\"idat\":"[off:])
			w.Int(o.IDat)
			off = 0
		}
		if c[13] {
			w.Raw(",\"islc\":"[off:])
			w.Ints(o.ISlc)
			off = 0
		}
		if c[14] {
			w.Raw(",\"iptr\":"[off:])
			w.Intp(o.IPtr)
			off = 0
		}
		w.Byte('}')
	}
}

func (o *IntegersColl) EncodeSlicePJSON(w *writer.Writer, filter []parse.Filter, slc []IntegersColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].EncodeObjectPJSON(w, filter)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].EncodeObjectPJSON(w, filter)
		}
		w.Byte(']')
	}
}

func (o *IntegersColl) ObjectLengthPJSON(filter []parse.Filter) (bytes int, volatile int) {
	if o == nil {
		return 4, 0
	} else {
		c := [15]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "i8dat" {
					c[0] = true
				} else if k == "i8slc" {
					c[1] = true
				} else if k == "i8ptr" {
					c[2] = true
				} else if k == "i16dat" {
					c[3] = true
				} else if k == "i16slc" {
					c[4] = true
				} else if k == "i16ptr" {
					c[5] = true
				} else if k == "i32dat" {
					c[6] = true
				} else if k == "i32slc" {
					c[7] = true
				} else if k == "i32ptr" {
					c[8] = true
				} else if k == "i64dat" {
					c[9] = true
				} else if k == "i64slc" {
					c[10] = true
				} else if k == "i64ptr" {
					c[11] = true
				} else if k == "idat" {
					c[12] = true
				} else if k == "islc" {
					c[13] = true
				} else if k == "iptr" {
					c[14] = true
				}
			}
		}
		if c[0] {
			bytes += writer.Int8Len(o.I8Dat) + 9
		}
		if c[1] {
			bytes += writer.Int8sLen(o.I8Slc) + 9
		}
		if c[2] {
			bytes += writer.Int8pLen(o.I8Ptr) + 9
		}
		if c[3] {
			bytes += writer.Int16Len(o.I16Dat) + 10
		}
		if c[4] {
			bytes += writer.Int16sLen(o.I16Slc) + 10
		}
		if c[5] {
			bytes += writer.Int16pLen(o.I16Ptr) + 10
		}
		if c[6] {
			bytes += writer.Int32Len(o.I32Dat) + 10
		}
		if c[7] {
			bytes += writer.Int32sLen(o.I32Slc) + 10
		}
		if c[8] {
			bytes += writer.Int32pLen(o.I32Ptr) + 10
		}
		if c[9] {
			bytes += writer.Int64Len(o.I64Dat) + 10
		}
		if c[10] {
			bytes += writer.Int64sLen(o.I64Slc) + 10
		}
		if c[11] {
			bytes += writer.Int64pLen(o.I64Ptr) + 10
		}
		if c[12] {
			bytes += writer.IntLen(o.IDat) + 8
		}
		if c[13] {
			bytes += writer.IntsLen(o.ISlc) + 8
		}
		if c[14] {
			bytes += writer.IntpLen(o.IPtr) + 8
		}
		if bytes == 0 {
			return 2, 0
		} else {
			return bytes + 1, volatile
		}
	}
}

func (o *IntegersColl) SliceLengthPJSON(filter []parse.Filter, slc []IntegersColl) (bytes int, volatile int) {
	for _, obj := range slc {
		b, v := obj.ObjectLengthPJSON(filter)
		bytes, volatile = bytes+b+1, volatile+v
	}
	if bytes == 0 {
		return 2, 0
	} else {
		return bytes + 1, volatile
	}
}

func (o *StringsColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [6]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "sdat" {
				c[0] = true
			} else if k == "sslc" {
				c[1] = true
			} else if k == "sptr" {
				c[2] = true
			} else if k == "tdat" {
				c[3] = true
			} else if k == "tslc" {
				c[4] = true
			} else if k == "tptr" {
				c[5] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "sdat" && c[0] {
						o.SDat, err = r.GetString()
					} else if string(key) == "sslc" && c[1] {
						o.SSlc, err = r.GetStrings()
					} else if string(key) == "sptr" && c[2] {
						o.SPtr, err = r.GetStringPtr()
					} else if string(key) == "tdat" && c[3] {
						o.TDat, err = r.GetTime()
					} else if string(key) == "tslc" && c[4] {
						o.TSlc, err = r.GetTimes()
					} else if string(key) == "tptr" && c[5] {
						o.TPtr, err = r.GetTimePtr()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *StringsColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []StringsColl, err error) {
	var e StringsColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]StringsColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *StringsColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []StringsColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *StringsColl) EncodeObjectPJSON(w *writer.Writer, filter []parse.Filter) {
	if o == nil {
		w.Raw("null")
	} else {
		c := [6]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "sdat" {
					c[0] = true
				} else if k == "sslc" {
					c[1] = true
				} else if k == "sptr" {
					c[2] = true
				} else if k == "tdat" {
					c[3] = true
				} else if k == "tslc" {
					c[4] = true
				} else if k == "tptr" {
					c[5] = true
				}
			}
		}
		w.Byte('{')
		off := 1
		if c[0] {
			w.Raw(",\"sdat\":"[off:])
			w.String(o.SDat)
			off = 0
		}
		if c[1] {
			w.Raw(",\"sslc\":"[off:])
			w.Strings(o.SSlc)
			off = 0
		}
		if c[2] {
			w.Raw(",\"sptr\":"[off:])
			w.Stringp(o.SPtr)
			off = 0
		}
		if c[3] {
			w.Raw(",\"tdat\":"[off:])
			w.Time(o.TDat)
			off = 0
		}
		if c[4] {
			w.Raw(",\"tslc\":"[off:])
			w.Times(o.TSlc)
			off = 0
		}
		if c[5] {
			w.Raw(",\"tptr\":"[off:])
			w.Timep(o.TPtr)
			off = 0
		}
		w.Byte('}')
	}
}

func (o *StringsColl) EncodeSlicePJSON(w *writer.Writer, filter []parse.Filter, slc []StringsColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].EncodeObjectPJSON(w, filter)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].EncodeObjectPJSON(w, filter)
		}
		w.Byte(']')
	}
}

func (o *StringsColl) ObjectLengthPJSON(filter []parse.Filter) (bytes int, volatile int) {
	if o == nil {
		return 4, 0
	} else {
		c := [6]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "sdat" {
					c[0] = true
				} else if k == "sslc" {
					c[1] = true
				} else if k == "sptr" {
					c[2] = true
				} else if k == "tdat" {
					c[3] = true
				} else if k == "tslc" {
					c[4] = true
				} else if k == "tptr" {
					c[5] = true
				}
			}
		}
		if c[0] {
			b, v := writer.StringLen(o.SDat)
			bytes, volatile = bytes+b+8, volatile+v
		}
		if c[1] {
			b, v := writer.StringsLen(o.SSlc)
			bytes, volatile = bytes+b+8, volatile+v
		}
		if c[2] {
			b, v := writer.StringpLen(o.SPtr)
			bytes, volatile = bytes+b+8, volatile+v
		}
		if c[3] {
			bytes += writer.TimeLen(o.TDat) + 8
		}
		if c[4] {
			bytes += writer.TimesLen(o.TSlc) + 8
		}
		if c[5] {
			bytes += writer.TimepLen(o.TPtr) + 8
		}
		if bytes == 0 {
			return 2, 0
		} else {
			return bytes + 1, volatile
		}
	}
}

func (o *StringsColl) SliceLengthPJSON(filter []parse.Filter, slc []StringsColl) (bytes int, volatile int) {
	for _, obj := range slc {
		b, v := obj.ObjectLengthPJSON(filter)
		bytes, volatile = bytes+b+1, volatile+v
	}
	if bytes == 0 {
		return 2, 0
	} else {
		return bytes + 1, volatile
	}
}

func (o *UnsignedIntegersColl) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [15]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "ui8dat" {
				c[0] = true
			} else if k == "ui8slc" {
				c[1] = true
			} else if k == "ui8ptr" {
				c[2] = true
			} else if k == "ui16dat" {
				c[3] = true
			} else if k == "ui16slc" {
				c[4] = true
			} else if k == "ui16ptr" {
				c[5] = true
			} else if k == "ui32dat" {
				c[6] = true
			} else if k == "ui32slc" {
				c[7] = true
			} else if k == "ui32ptr" {
				c[8] = true
			} else if k == "ui64dat" {
				c[9] = true
			} else if k == "ui64slc" {
				c[10] = true
			} else if k == "ui64ptr" {
				c[11] = true
			} else if k == "uidat" {
				c[12] = true
			} else if k == "uislc" {
				c[13] = true
			} else if k == "uiptr" {
				c[14] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "ui8dat" && c[0] {
						o.UI8Dat, err = r.GetUInt8()
					} else if string(key) == "ui8slc" && c[1] {
						o.UI8Slc, err = r.GetUInt8s()
					} else if string(key) == "ui8ptr" && c[2] {
						o.UI8Ptr, err = r.GetUInt8Ptr()
					} else if string(key) == "ui16dat" && c[3] {
						o.UI16Dat, err = r.GetUInt16()
					} else if string(key) == "ui16slc" && c[4] {
						o.UI16Slc, err = r.GetUInt16s()
					} else if string(key) == "ui16ptr" && c[5] {
						o.UI16Ptr, err = r.GetUInt16Ptr()
					} else if string(key) == "ui32dat" && c[6] {
						o.UI32Dat, err = r.GetUInt32()
					} else if string(key) == "ui32slc" && c[7] {
						o.UI32Slc, err = r.GetUInt32s()
					} else if string(key) == "ui32ptr" && c[8] {
						o.UI32Ptr, err = r.GetUInt32Ptr()
					} else if string(key) == "ui64dat" && c[9] {
						o.UI64Dat, err = r.GetUInt64()
					} else if string(key) == "ui64slc" && c[10] {
						o.UI64Slc, err = r.GetUInt64s()
					} else if string(key) == "ui64ptr" && c[11] {
						o.UI64Ptr, err = r.GetUInt64Ptr()
					} else if string(key) == "uidat" && c[12] {
						o.UIDat, err = r.GetUInt()
					} else if string(key) == "uislc" && c[13] {
						o.UISlc, err = r.GetUInts()
					} else if string(key) == "uiptr" && c[14] {
						o.UIPtr, err = r.GetUIntPtr()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *UnsignedIntegersColl) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []UnsignedIntegersColl, err error) {
	var e UnsignedIntegersColl
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]UnsignedIntegersColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *UnsignedIntegersColl) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []UnsignedIntegersColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *UnsignedIntegersColl) EncodeObjectPJSON(w *writer.Writer, filter []parse.Filter) {
	if o == nil {
		w.Raw("null")
	} else {
		c := [15]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "ui8dat" {
					c[0] = true
				} else if k == "ui8slc" {
					c[1] = true
				} else if k == "ui8ptr" {
					c[2] = true
				} else if k == "ui16dat" {
					c[3] = true
				} else if k == "ui16slc" {
					c[4] = true
				} else if k == "ui16ptr" {
					c[5] = true
				} else if k == "ui32dat" {
					c[6] = true
				} else if k == "ui32slc" {
					c[7] = true
				} else if k == "ui32ptr" {
					c[8] = true
				} else if k == "ui64dat" {
					c[9] = true
				} else if k == "ui64slc" {
					c[10] = true
				} else if k == "ui64ptr" {
					c[11] = true
				} else if k == "uidat" {
					c[12] = true
				} else if k == "uislc" {
					c[13] = true
				} else if k == "uiptr" {
					c[14] = true
				}
			}
		}
		w.Byte('{')
		off := 1
		if c[0] {
			w.Raw(",\"ui8dat\":"[off:])
			w.UInt8(o.UI8Dat)
			off = 0
		}
		if c[1] {
			w.Raw(",\"ui8slc\":"[off:])
			w.UInt8s(o.UI8Slc)
			off = 0
		}
		if c[2] {
			w.Raw(",\"ui8ptr\":"[off:])
			w.UInt8p(o.UI8Ptr)
			off = 0
		}
		if c[3] {
			w.Raw(",\"ui16dat\":"[off:])
			w.UInt16(o.UI16Dat)
			off = 0
		}
		if c[4] {
			w.Raw(",\"ui16slc\":"[off:])
			w.UInt16s(o.UI16Slc)
			off = 0
		}
		if c[5] {
			w.Raw(",\"ui16ptr\":"[off:])
			w.UInt16p(o.UI16Ptr)
			off = 0
		}
		if c[6] {
			w.Raw(",\"ui32dat\":"[off:])
			w.UInt32(o.UI32Dat)
			off = 0
		}
		if c[7] {
			w.Raw(",\"ui32slc\":"[off:])
			w.UInt32s(o.UI32Slc)
			off = 0
		}
		if c[8] {
			w.Raw(",\"ui32ptr\":"[off:])
			w.UInt32p(o.UI32Ptr)
			off = 0
		}
		if c[9] {
			w.Raw(",\"ui64dat\":"[off:])
			w.UInt64(o.UI64Dat)
			off = 0
		}
		if c[10] {
			w.Raw(",\"ui64slc\":"[off:])
			w.UInt64s(o.UI64Slc)
			off = 0
		}
		if c[11] {
			w.Raw(",\"ui64ptr\":"[off:])
			w.UInt64p(o.UI64Ptr)
			off = 0
		}
		if c[12] {
			w.Raw(",\"uidat\":"[off:])
			w.UInt(o.UIDat)
			off = 0
		}
		if c[13] {
			w.Raw(",\"uislc\":"[off:])
			w.UInts(o.UISlc)
			off = 0
		}
		if c[14] {
			w.Raw(",\"uiptr\":"[off:])
			w.UIntp(o.UIPtr)
			off = 0
		}
		w.Byte('}')
	}
}

func (o *UnsignedIntegersColl) EncodeSlicePJSON(w *writer.Writer, filter []parse.Filter, slc []UnsignedIntegersColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].EncodeObjectPJSON(w, filter)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].EncodeObjectPJSON(w, filter)
		}
		w.Byte(']')
	}
}

func (o *UnsignedIntegersColl) ObjectLengthPJSON(filter []parse.Filter) (bytes int, volatile int) {
	if o == nil {
		return 4, 0
	} else {
		c := [15]bool{}
		if filter == nil {
			for i := range c {
				c[i] = true
			}
		} else {
			for i := range filter {
				k := filter[i].Field
				if k == "ui8dat" {
					c[0] = true
				} else if k == "ui8slc" {
					c[1] = true
				} else if k == "ui8ptr" {
					c[2] = true
				} else if k == "ui16dat" {
					c[3] = true
				} else if k == "ui16slc" {
					c[4] = true
				} else if k == "ui16ptr" {
					c[5] = true
				} else if k == "ui32dat" {
					c[6] = true
				} else if k == "ui32slc" {
					c[7] = true
				} else if k == "ui32ptr" {
					c[8] = true
				} else if k == "ui64dat" {
					c[9] = true
				} else if k == "ui64slc" {
					c[10] = true
				} else if k == "ui64ptr" {
					c[11] = true
				} else if k == "uidat" {
					c[12] = true
				} else if k == "uislc" {
					c[13] = true
				} else if k == "uiptr" {
					c[14] = true
				}
			}
		}
		if c[0] {
			bytes += writer.UInt8Len(o.UI8Dat) + 10
		}
		if c[1] {
			bytes += writer.UInt8sLen(o.UI8Slc) + 10
		}
		if c[2] {
			bytes += writer.UInt8pLen(o.UI8Ptr) + 10
		}
		if c[3] {
			bytes += writer.UInt16Len(o.UI16Dat) + 11
		}
		if c[4] {
			bytes += writer.UInt16sLen(o.UI16Slc) + 11
		}
		if c[5] {
			bytes += writer.UInt16pLen(o.UI16Ptr) + 11
		}
		if c[6] {
			bytes += writer.UInt32Len(o.UI32Dat) + 11
		}
		if c[7] {
			bytes += writer.UInt32sLen(o.UI32Slc) + 11
		}
		if c[8] {
			bytes += writer.UInt32pLen(o.UI32Ptr) + 11
		}
		if c[9] {
			bytes += writer.UInt64Len(o.UI64Dat) + 11
		}
		if c[10] {
			bytes += writer.UInt64sLen(o.UI64Slc) + 11
		}
		if c[11] {
			bytes += writer.UInt64pLen(o.UI64Ptr) + 11
		}
		if c[12] {
			bytes += writer.UIntLen(o.UIDat) + 9
		}
		if c[13] {
			bytes += writer.UIntsLen(o.UISlc) + 9
		}
		if c[14] {
			bytes += writer.UIntpLen(o.UIPtr) + 9
		}
		if bytes == 0 {
			return 2, 0
		} else {
			return bytes + 1, volatile
		}
	}
}

func (o *UnsignedIntegersColl) SliceLengthPJSON(filter []parse.Filter, slc []UnsignedIntegersColl) (bytes int, volatile int) {
	for _, obj := range slc {
		b, v := obj.ObjectLengthPJSON(filter)
		bytes, volatile = bytes+b+1, volatile+v
	}
	if bytes == 0 {
		return 2, 0
	} else {
		return bytes + 1, volatile
	}
}
