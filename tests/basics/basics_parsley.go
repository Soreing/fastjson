// Code generated by parsley for scanning JSON strings. DO NOT EDIT.
package basics

import (
	reader "github.com/Soreing/parsley/reader"
	writer "github.com/Soreing/parsley/writer"
)

var _ *reader.Reader
var _ *writer.Writer

func (o *BooleansColl) UnmarshalParsleyJSON(r *reader.Reader) (err error) {
	var key []byte
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					switch string(key) {
					case "bdat":
						o.BDat, err = r.GetBool()
					case "bslc":
						o.BSlc, err = r.GetBools()
					case "bptr":
						o.BPtr, err = r.GetBoolPtr()
					default:
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *BooleansColl) sequenceParsleyJSON(r *reader.Reader, idx int) (res []BooleansColl, err error) {
	var e BooleansColl
	if err = e.UnmarshalParsleyJSON(r); err == nil {
		if !r.Next() {
			res = make([]BooleansColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequenceParsleyJSON(r, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *BooleansColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []BooleansColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *BooleansColl) MarshalParsleyJSON(w *writer.Writer) {
	if o == nil {
		w.Raw("null")
	} else {
		w.Byte('{')
		off := 1
		w.Raw(",\"bdat\":"[off:])
		w.Bool(o.BDat)
		off = 0
		w.Raw(",\"bslc\":")
		w.Bools(o.BSlc)
		w.Raw(",\"bptr\":")
		w.Boolp(o.BPtr)
		w.Byte('}')
	}
}

func (o *BooleansColl) MarshalParsleyJSONSlice(w *writer.Writer, slc []BooleansColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].MarshalParsleyJSON(w)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].MarshalParsleyJSON(w)
		}
		w.Byte(']')
	}
}

func (o *BooleansColl) LengthParsleyJSON() (ln int) {
	if o == nil {
		return 4
	}
	ln = 37
	if o.BDat != false {
		ln += writer.BoolLen(o.BDat) - 5
	}
	if o.BSlc != nil {
		ln += writer.BoolsLen(o.BSlc) - 4
	}
	if o.BPtr != nil {
		ln += writer.BoolLen(*o.BPtr) - 4
	}
	if ln == 0 {
		return 2
	}
	return ln + 1
}

func (o *BooleansColl) LengthParsleyJSONSlice(slc []BooleansColl) (ln int) {
	for _, obj := range slc {
		ln += obj.LengthParsleyJSON() + 1
	}
	if ln == 0 {
		return 2
	} else {
		return ln + 1
	}
}

func (o *FloatingPointColl) UnmarshalParsleyJSON(r *reader.Reader) (err error) {
	var key []byte
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					switch string(key) {
					case "f32dat":
						o.F32Dat, err = r.GetFloat32()
					case "f32slc":
						o.F32Slc, err = r.GetFloat32s()
					case "f32ptr":
						o.F32Ptr, err = r.GetFloat32Ptr()
					case "f64dat":
						o.F64Dat, err = r.GetFloat64()
					case "f64slc":
						o.F64Slc, err = r.GetFloat64s()
					case "f64ptr":
						o.F64Ptr, err = r.GetFloat64Ptr()
					default:
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *FloatingPointColl) sequenceParsleyJSON(r *reader.Reader, idx int) (res []FloatingPointColl, err error) {
	var e FloatingPointColl
	if err = e.UnmarshalParsleyJSON(r); err == nil {
		if !r.Next() {
			res = make([]FloatingPointColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequenceParsleyJSON(r, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *FloatingPointColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []FloatingPointColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *FloatingPointColl) MarshalParsleyJSON(w *writer.Writer) {
	if o == nil {
		w.Raw("null")
	} else {
		w.Byte('{')
		off := 1
		w.Raw(",\"f32dat\":"[off:])
		w.Float32(o.F32Dat)
		off = 0
		w.Raw(",\"f32slc\":")
		w.Float32s(o.F32Slc)
		w.Raw(",\"f32ptr\":")
		w.Float32p(o.F32Ptr)
		w.Raw(",\"f64dat\":")
		w.Float64(o.F64Dat)
		w.Raw(",\"f64slc\":")
		w.Float64s(o.F64Slc)
		w.Raw(",\"f64ptr\":")
		w.Float64p(o.F64Ptr)
		w.Byte('}')
	}
}

func (o *FloatingPointColl) MarshalParsleyJSONSlice(w *writer.Writer, slc []FloatingPointColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].MarshalParsleyJSON(w)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].MarshalParsleyJSON(w)
		}
		w.Byte(']')
	}
}

func (o *FloatingPointColl) LengthParsleyJSON() (ln int) {
	if o == nil {
		return 4
	}
	ln = 78
	if o.F32Dat != 0 {
		ln += writer.Float32Len(o.F32Dat) - 1
	}
	if o.F32Slc != nil {
		ln += writer.Float32sLen(o.F32Slc) - 4
	}
	if o.F32Ptr != nil {
		ln += writer.Float32Len(*o.F32Ptr) - 4
	}
	if o.F64Dat != 0 {
		ln += writer.Float64Len(o.F64Dat) - 1
	}
	if o.F64Slc != nil {
		ln += writer.Float64sLen(o.F64Slc) - 4
	}
	if o.F64Ptr != nil {
		ln += writer.Float64Len(*o.F64Ptr) - 4
	}
	if ln == 0 {
		return 2
	}
	return ln + 1
}

func (o *FloatingPointColl) LengthParsleyJSONSlice(slc []FloatingPointColl) (ln int) {
	for _, obj := range slc {
		ln += obj.LengthParsleyJSON() + 1
	}
	if ln == 0 {
		return 2
	} else {
		return ln + 1
	}
}

func (o *IntegersColl) UnmarshalParsleyJSON(r *reader.Reader) (err error) {
	var key []byte
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					switch string(key) {
					case "i8dat":
						o.I8Dat, err = r.GetInt8()
					case "i8slc":
						o.I8Slc, err = r.GetInt8s()
					case "i8ptr":
						o.I8Ptr, err = r.GetInt8Ptr()
					case "i16dat":
						o.I16Dat, err = r.GetInt16()
					case "i16slc":
						o.I16Slc, err = r.GetInt16s()
					case "i16ptr":
						o.I16Ptr, err = r.GetInt16Ptr()
					case "i32dat":
						o.I32Dat, err = r.GetInt32()
					case "i32slc":
						o.I32Slc, err = r.GetInt32s()
					case "i32ptr":
						o.I32Ptr, err = r.GetInt32Ptr()
					case "i64dat":
						o.I64Dat, err = r.GetInt64()
					case "i64slc":
						o.I64Slc, err = r.GetInt64s()
					case "i64ptr":
						o.I64Ptr, err = r.GetInt64Ptr()
					case "idat":
						o.IDat, err = r.GetInt()
					case "islc":
						o.ISlc, err = r.GetInts()
					case "iptr":
						o.IPtr, err = r.GetIntPtr()
					default:
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *IntegersColl) sequenceParsleyJSON(r *reader.Reader, idx int) (res []IntegersColl, err error) {
	var e IntegersColl
	if err = e.UnmarshalParsleyJSON(r); err == nil {
		if !r.Next() {
			res = make([]IntegersColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequenceParsleyJSON(r, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *IntegersColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []IntegersColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *IntegersColl) MarshalParsleyJSON(w *writer.Writer) {
	if o == nil {
		w.Raw("null")
	} else {
		w.Byte('{')
		off := 1
		w.Raw(",\"i8dat\":"[off:])
		w.Int8(o.I8Dat)
		off = 0
		w.Raw(",\"i8slc\":")
		w.Int8s(o.I8Slc)
		w.Raw(",\"i8ptr\":")
		w.Int8p(o.I8Ptr)
		w.Raw(",\"i16dat\":")
		w.Int16(o.I16Dat)
		w.Raw(",\"i16slc\":")
		w.Int16s(o.I16Slc)
		w.Raw(",\"i16ptr\":")
		w.Int16p(o.I16Ptr)
		w.Raw(",\"i32dat\":")
		w.Int32(o.I32Dat)
		w.Raw(",\"i32slc\":")
		w.Int32s(o.I32Slc)
		w.Raw(",\"i32ptr\":")
		w.Int32p(o.I32Ptr)
		w.Raw(",\"i64dat\":")
		w.Int64(o.I64Dat)
		w.Raw(",\"i64slc\":")
		w.Int64s(o.I64Slc)
		w.Raw(",\"i64ptr\":")
		w.Int64p(o.I64Ptr)
		w.Raw(",\"idat\":")
		w.Int(o.IDat)
		w.Raw(",\"islc\":")
		w.Ints(o.ISlc)
		w.Raw(",\"iptr\":")
		w.Intp(o.IPtr)
		w.Byte('}')
	}
}

func (o *IntegersColl) MarshalParsleyJSONSlice(w *writer.Writer, slc []IntegersColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].MarshalParsleyJSON(w)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].MarshalParsleyJSON(w)
		}
		w.Byte(']')
	}
}

func (o *IntegersColl) LengthParsleyJSON() (ln int) {
	if o == nil {
		return 4
	}
	ln = 186
	if o.I8Dat != 0 {
		ln += writer.Int8Len(o.I8Dat) - 1
	}
	if o.I8Slc != nil {
		ln += writer.Int8sLen(o.I8Slc) - 4
	}
	if o.I8Ptr != nil {
		ln += writer.Int8Len(*o.I8Ptr) - 4
	}
	if o.I16Dat != 0 {
		ln += writer.Int16Len(o.I16Dat) - 1
	}
	if o.I16Slc != nil {
		ln += writer.Int16sLen(o.I16Slc) - 4
	}
	if o.I16Ptr != nil {
		ln += writer.Int16Len(*o.I16Ptr) - 4
	}
	if o.I32Dat != 0 {
		ln += writer.Int32Len(o.I32Dat) - 1
	}
	if o.I32Slc != nil {
		ln += writer.Int32sLen(o.I32Slc) - 4
	}
	if o.I32Ptr != nil {
		ln += writer.Int32Len(*o.I32Ptr) - 4
	}
	if o.I64Dat != 0 {
		ln += writer.Int64Len(o.I64Dat) - 1
	}
	if o.I64Slc != nil {
		ln += writer.Int64sLen(o.I64Slc) - 4
	}
	if o.I64Ptr != nil {
		ln += writer.Int64Len(*o.I64Ptr) - 4
	}
	if o.IDat != 0 {
		ln += writer.IntLen(o.IDat) - 1
	}
	if o.ISlc != nil {
		ln += writer.IntsLen(o.ISlc) - 4
	}
	if o.IPtr != nil {
		ln += writer.IntLen(*o.IPtr) - 4
	}
	if ln == 0 {
		return 2
	}
	return ln + 1
}

func (o *IntegersColl) LengthParsleyJSONSlice(slc []IntegersColl) (ln int) {
	for _, obj := range slc {
		ln += obj.LengthParsleyJSON() + 1
	}
	if ln == 0 {
		return 2
	} else {
		return ln + 1
	}
}

func (o *StringsColl) UnmarshalParsleyJSON(r *reader.Reader) (err error) {
	var key []byte
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					switch string(key) {
					case "sdat":
						o.SDat, err = r.GetString()
					case "sslc":
						o.SSlc, err = r.GetStrings()
					case "sptr":
						o.SPtr, err = r.GetStringPtr()
					case "tdat":
						o.TDat, err = r.GetTime()
					case "tslc":
						o.TSlc, err = r.GetTimes()
					case "tptr":
						o.TPtr, err = r.GetTimePtr()
					default:
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *StringsColl) sequenceParsleyJSON(r *reader.Reader, idx int) (res []StringsColl, err error) {
	var e StringsColl
	if err = e.UnmarshalParsleyJSON(r); err == nil {
		if !r.Next() {
			res = make([]StringsColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequenceParsleyJSON(r, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *StringsColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []StringsColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *StringsColl) MarshalParsleyJSON(w *writer.Writer) {
	if o == nil {
		w.Raw("null")
	} else {
		w.Byte('{')
		off := 1
		w.Raw(",\"sdat\":"[off:])
		w.String(o.SDat)
		off = 0
		w.Raw(",\"sslc\":")
		w.Strings(o.SSlc)
		w.Raw(",\"sptr\":")
		w.Stringp(o.SPtr)
		w.Raw(",\"tdat\":")
		w.Time(o.TDat)
		w.Raw(",\"tslc\":")
		w.Times(o.TSlc)
		w.Raw(",\"tptr\":")
		w.Timep(o.TPtr)
		w.Byte('}')
	}
}

func (o *StringsColl) MarshalParsleyJSONSlice(w *writer.Writer, slc []StringsColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].MarshalParsleyJSON(w)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].MarshalParsleyJSON(w)
		}
		w.Byte(']')
	}
}

func (o *StringsColl) LengthParsleyJSON() (ln int) {
	if o == nil {
		return 4
	}
	ln = 88
	if o.SDat != "" {
		ln += writer.StringLen(o.SDat) - 2
	}
	if o.SSlc != nil {
		ln += writer.StringsLen(o.SSlc) - 4
	}
	if o.SPtr != nil {
		ln += writer.StringLen(*o.SPtr) - 4
	}
	if o.TDat.IsZero() != true {
		ln += writer.TimeLen(o.TDat) - 22
	}
	if o.TSlc != nil {
		ln += writer.TimesLen(o.TSlc) - 4
	}
	if o.TPtr != nil {
		ln += writer.TimeLen(*o.TPtr) - 4
	}
	if ln == 0 {
		return 2
	}
	return ln + 1
}

func (o *StringsColl) LengthParsleyJSONSlice(slc []StringsColl) (ln int) {
	for _, obj := range slc {
		ln += obj.LengthParsleyJSON() + 1
	}
	if ln == 0 {
		return 2
	} else {
		return ln + 1
	}
}

func (o *UnsignedIntegersColl) UnmarshalParsleyJSON(r *reader.Reader) (err error) {
	var key []byte
	err = r.OpenObject()
	if r.GetType() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.GetKey(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					switch string(key) {
					case "ui8dat":
						o.UI8Dat, err = r.GetUInt8()
					case "ui8slc":
						o.UI8Slc, err = r.GetUInt8s()
					case "ui8ptr":
						o.UI8Ptr, err = r.GetUInt8Ptr()
					case "ui16dat":
						o.UI16Dat, err = r.GetUInt16()
					case "ui16slc":
						o.UI16Slc, err = r.GetUInt16s()
					case "ui16ptr":
						o.UI16Ptr, err = r.GetUInt16Ptr()
					case "ui32dat":
						o.UI32Dat, err = r.GetUInt32()
					case "ui32slc":
						o.UI32Slc, err = r.GetUInt32s()
					case "ui32ptr":
						o.UI32Ptr, err = r.GetUInt32Ptr()
					case "ui64dat":
						o.UI64Dat, err = r.GetUInt64()
					case "ui64slc":
						o.UI64Slc, err = r.GetUInt64s()
					case "ui64ptr":
						o.UI64Ptr, err = r.GetUInt64Ptr()
					case "uidat":
						o.UIDat, err = r.GetUInt()
					case "uislc":
						o.UISlc, err = r.GetUInts()
					case "uiptr":
						o.UIPtr, err = r.GetUIntPtr()
					default:
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *UnsignedIntegersColl) sequenceParsleyJSON(r *reader.Reader, idx int) (res []UnsignedIntegersColl, err error) {
	var e UnsignedIntegersColl
	if err = e.UnmarshalParsleyJSON(r); err == nil {
		if !r.Next() {
			res = make([]UnsignedIntegersColl, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequenceParsleyJSON(r, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *UnsignedIntegersColl) UnmarshalParsleyJSONSlice(r *reader.Reader) (res []UnsignedIntegersColl, err error) {
	if err = r.OpenArray(); err == nil {
		if res, err = o.sequenceParsleyJSON(r, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *UnsignedIntegersColl) MarshalParsleyJSON(w *writer.Writer) {
	if o == nil {
		w.Raw("null")
	} else {
		w.Byte('{')
		off := 1
		w.Raw(",\"ui8dat\":"[off:])
		w.UInt8(o.UI8Dat)
		off = 0
		w.Raw(",\"ui8slc\":")
		w.UInt8s(o.UI8Slc)
		w.Raw(",\"ui8ptr\":")
		w.UInt8p(o.UI8Ptr)
		w.Raw(",\"ui16dat\":")
		w.UInt16(o.UI16Dat)
		w.Raw(",\"ui16slc\":")
		w.UInt16s(o.UI16Slc)
		w.Raw(",\"ui16ptr\":")
		w.UInt16p(o.UI16Ptr)
		w.Raw(",\"ui32dat\":")
		w.UInt32(o.UI32Dat)
		w.Raw(",\"ui32slc\":")
		w.UInt32s(o.UI32Slc)
		w.Raw(",\"ui32ptr\":")
		w.UInt32p(o.UI32Ptr)
		w.Raw(",\"ui64dat\":")
		w.UInt64(o.UI64Dat)
		w.Raw(",\"ui64slc\":")
		w.UInt64s(o.UI64Slc)
		w.Raw(",\"ui64ptr\":")
		w.UInt64p(o.UI64Ptr)
		w.Raw(",\"uidat\":")
		w.UInt(o.UIDat)
		w.Raw(",\"uislc\":")
		w.UInts(o.UISlc)
		w.Raw(",\"uiptr\":")
		w.UIntp(o.UIPtr)
		w.Byte('}')
	}
}

func (o *UnsignedIntegersColl) MarshalParsleyJSONSlice(w *writer.Writer, slc []UnsignedIntegersColl) {
	if slc == nil {
		w.Raw("null")
	} else if len(slc) == 0 {
		w.Raw("[]")
	} else {
		w.Byte('[')
		slc[0].MarshalParsleyJSON(w)
		for i := 1; i < len(slc); i++ {
			w.Byte(',')
			slc[i].MarshalParsleyJSON(w)
		}
		w.Byte(']')
	}
}

func (o *UnsignedIntegersColl) LengthParsleyJSON() (ln int) {
	if o == nil {
		return 4
	}
	ln = 201
	if o.UI8Dat != 0 {
		ln += writer.UInt8Len(o.UI8Dat) - 1
	}
	if o.UI8Slc != nil {
		ln += writer.UInt8sLen(o.UI8Slc) - 4
	}
	if o.UI8Ptr != nil {
		ln += writer.UInt8Len(*o.UI8Ptr) - 4
	}
	if o.UI16Dat != 0 {
		ln += writer.UInt16Len(o.UI16Dat) - 1
	}
	if o.UI16Slc != nil {
		ln += writer.UInt16sLen(o.UI16Slc) - 4
	}
	if o.UI16Ptr != nil {
		ln += writer.UInt16Len(*o.UI16Ptr) - 4
	}
	if o.UI32Dat != 0 {
		ln += writer.UInt32Len(o.UI32Dat) - 1
	}
	if o.UI32Slc != nil {
		ln += writer.UInt32sLen(o.UI32Slc) - 4
	}
	if o.UI32Ptr != nil {
		ln += writer.UInt32Len(*o.UI32Ptr) - 4
	}
	if o.UI64Dat != 0 {
		ln += writer.UInt64Len(o.UI64Dat) - 1
	}
	if o.UI64Slc != nil {
		ln += writer.UInt64sLen(o.UI64Slc) - 4
	}
	if o.UI64Ptr != nil {
		ln += writer.UInt64Len(*o.UI64Ptr) - 4
	}
	if o.UIDat != 0 {
		ln += writer.UIntLen(o.UIDat) - 1
	}
	if o.UISlc != nil {
		ln += writer.UIntsLen(o.UISlc) - 4
	}
	if o.UIPtr != nil {
		ln += writer.UIntLen(*o.UIPtr) - 4
	}
	if ln == 0 {
		return 2
	}
	return ln + 1
}

func (o *UnsignedIntegersColl) LengthParsleyJSONSlice(slc []UnsignedIntegersColl) (ln int) {
	for _, obj := range slc {
		ln += obj.LengthParsleyJSON() + 1
	}
	if ln == 0 {
		return 2
	} else {
		return ln + 1
	}
}
